<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>2DEngine</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <link rel="stylesheet" href="style.css" />
  <style>
    #ui-panel.dragging { opacity: 0.92; cursor: move; }
    #ui-panel.resizing { opacity: 0.97; cursor: se-resize; }
    #ui-panel .drag-handle {
      cursor: move;
      color: #0a66ff;
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 7px;
      display: flex;
      align-items: center;
      gap: 7px;
      user-select: none;
    }
    #ui-panel .drag-handle .move-ico {font-size: 18px;}
    .param-fields {
      display: flex; flex-wrap: wrap; gap: 8px 10px; margin-bottom:8px; align-items: center;
    }
    .param-fields label {font-size: 13px; color: #00557f; margin-right: 2px; font-weight: 500;}
    .param-fields input[type="number"] {width: 52px; border-radius: 4px; border: 1px solid #aad; padding: 2px 5px;}
    .param-fields input[type="color"] {width: 28px; height: 28px; padding: 0; border: none;}
    #bg-color-picker {margin-left: 2px; width: 28px; height: 28px; border:none; border-radius:6px; background:#fff; cursor:pointer;}
    .help-tip {font-size: 11px; color: #888; margin-top: 0; margin-bottom: 3px; line-height: 1.1;}
    #world-canvas { position: absolute; left: 0; top: 0; width: 100vw; height: 100vh; display: block; z-index: 1; }
    #ui-panel { position: absolute; z-index: 10; min-width: 320px; transition: all .25s; background: #fff; }
    #ui-panel .panel-controls {
      display: flex; align-items: center; gap: 7px; margin-bottom: 5px;
    }
    #ui-panel .panel-controls .close-btn {
      font-size: 18px; color: #888; cursor: pointer; padding:0 7px; background:none; border:none; border-radius:4px;
      transition: background 0.2s;
    }
    #ui-panel .panel-controls .close-btn:hover {
      background: #e3eaff;
      color: #0a66ff;
    }
    #ui-panel .resize-handle {
      position: absolute;
      right: 2px;
      bottom: 2px;
      width: 20px;
      height: 20px;
      cursor: se-resize;
      z-index: 999;
      background: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><line x1="6" y1="18" x2="18" y2="6" stroke="%230aa" stroke-width="2"/><line x1="12" y1="18" x2="18" y2="12" stroke="%230aa" stroke-width="2"/></svg>') no-repeat center center;
      opacity: 0.22;
      border-radius: 0 0 6px 0;
      transition: opacity .2s;
    }
    #ui-panel .resize-handle:hover { opacity: 0.55; }
    #ui-panel.hidden { display: none !important; }
    @media (max-width: 800px), (pointer: coarse) {
      #ui-panel {
        left: 0 !important;
        right: 0;
        top: auto !important;
        bottom: 0 !important;
        width: 100vw !important;
        min-width: 0 !important;
        max-width: 100vw !important;
        border-radius: 16px 16px 0 0;
        box-shadow: 0 -2px 16px rgba(0,0,0,0.24);
        padding-bottom: env(safe-area-inset-bottom,20px);
        background: #fff;
        font-size: 18px;
      }
      #ui-panel .drag-handle {
        cursor: pointer !important;
        justify-content: center;
        font-size: 19px;
        padding-top: 6px;
        padding-bottom: 2px;
      }
      .param-fields input[type="number"] {
        width: 70px;
        font-size: 18px;
        padding: 6px 8px;
      }
      #ui-panel .group, .param-fields {
        font-size: 17px;
        margin-bottom: 7px;
        gap: 12px 14px;
      }
      #ui-panel button, #ui-panel input[type="color"], #ui-panel select {
        font-size: 17px;
        min-height: 38px;
        min-width: 38px;
        border-radius: 8px;
      }
      #ui-panel select { min-width: 110px;}
      #ui-panel { touch-action: none; }
      #ui-panel .resize-handle { display: none; }
    }
    #selection-canvas {
      position: absolute;
      left: 0; top: 0; width: 100vw; height: 100vh;
      z-index: 8; pointer-events: none;
    }
    #ui-panel.inactive {
      opacity: 0.5 !important;
      transition: opacity 0.3s;
    }
    #attr-modal-bg {
      position: fixed; left:0; top:0; width:100vw; height:100vh; z-index:99; background:rgba(0,0,0,0.18); display:none;
    }
    #attr-modal {
      position: absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      background: #fff; border-radius:8px; box-shadow:0 4px 32px rgba(0,0,0,0.18);
      padding: 22px 32px 18px 32px; min-width:280px; min-height:80px; z-index:100;
      font-size: 16px; color: #123;
      display: none;
    }
    #attr-modal label {display: block;margin-bottom:8px;}
    #attr-modal input[type="number"] {width: 80px;}
    #attr-modal .close-btn {position:absolute; right:13px; top:10px; font-size:22px; color:#aaa; cursor:pointer;}
    #attr-modal .del-btn {background:#e44; color:#fff; border:none; border-radius:5px; padding:7px 18px; margin-top:14px; cursor:pointer;}
    #save-load-btns {margin-left:8px;}
    #save-btn, #load-btn {background:#fff;color:#00aaff;border:1px solid #00aaff;border-radius:5px;padding:5px 12px;font-size:15px;cursor:pointer;margin-right:4px;}
    #save-btn:hover, #load-btn:hover {background:#00aaff;color:#fff;}
  </style>
</head>
<body>
  <div id="ui-panel">
    <div class="panel-controls">
      <button class="close-btn" id="panel-hide-btn" title="隐藏面板">&#10006;</button>
      <span style="color:#0a66ff; font-weight:bold; font-size:18px; letter-spacing:0.5px;">XenosMC</span>
      <span class="logo" style="margin-left:auto;">引擎核心：Matter.js</span>
    </div>
    <div class="drag-handle" id="ui-drag-handle">
      <span class="move-ico">&#x2630;</span>
    </div>
    <div class="group">
      <select id="shape-type">
        <option value="rectangle">矩形</option>
        <option value="circle">圆形</option>
        <option value="polygon">正多边形</option>
        <option value="trapezoid">梯形</option>
        <option value="fromVertices">自定义多边形</option>
        <option value="composite">复合体</option>
        <option value="constraint">连杆（约束）</option>
        <option value="softbody">软体</option>
      </select>
      <input type="color" id="color-picker" title="物体颜色" value="#00aaff"/>
    </div>
    <div class="param-fields" id="param-fields"></div>
    <div class="help-tip" id="param-help"></div>
    <div class="group">
      <label>重力:
        <input type="range" id="gravity-slider" min="-2" max="2" step="0.01" value="1"/>
      </label>
      <span id="gravity-value">1.00</span>
      <label style="margin-left:14px;">背景:
        <input type="color" id="bg-color-picker" title="背景颜色" value="#ffffff"/>
      </label>
      <span id="save-load-btns">
        <button id="save-btn">保存场景</button>
        <button id="load-btn">导入场景</button>
        <input type="file" id="file-input" style="display:none">
      </span>
    </div>
    <div class="group">
      <button id="pause-btn">暂停</button>
      <button id="resume-btn" disabled>恢复</button>
      <button id="reset-btn">重置场景</button>
      <button id="clear-btn">清空物体</button>
      <button id="delete-btn" disabled>删除选中</button>
      <label style="margin-left:6px;"><input type="checkbox" id="energy-toggle"> 动能/重心</label>
    </div>
    <div class="group">
      <label><input type="checkbox" id="batch-mode"> 批量填充</label>
      <label>方块边长:
        <input type="number" id="batch-size" min="10" max="100" value="30" style="width:52px;">
      </label>
      <label style="margin-left:14px;"><input type="checkbox" id="group-mode"> 分组多选</label>
      <button id="panel-show-btn" style="display:none;margin-left:auto;background:#eaf4ff;color:#0a66ff;border:1px solid #b5d0ff;padding:6px 18px;border-radius:6px;min-width:60px;">显示面板</button>
    </div>
    <div class="resize-handle" id="ui-resize-handle"></div>
  </div>
  <div id="attr-modal-bg"></div>
  <div id="attr-modal">
    <span class="close-btn" id="attr-modal-close">&times;</span>
    <form id="attr-form">
      <div id="attr-fields"></div>
      <button type="button" class="del-btn" id="attr-del-btn">删除此物体</button>
    </form>
  </div>
  <canvas id="world-canvas"></canvas>
  <canvas id="selection-canvas"></canvas>
  <script src="matter.js"></script>
  <script>
// ========== 面板拖动/缩放/显示/隐藏 ==========
function isMobile() {
  return /Android|iPhone|iPad|iPod|Mobile|Tablet|Phone|Mobi/i.test(navigator.userAgent) || window.innerWidth <= 800;
}
function setPanelInitialPosition() {
  var uiPanel = document.getElementById('ui-panel');
  if(isMobile()) {
    uiPanel.style.left = "0";
    uiPanel.style.right = "0";
    uiPanel.style.bottom = "0";
    uiPanel.style.top = "auto";
    uiPanel.style.width = "100vw";
    uiPanel.style.height = "auto";
  } else {
    uiPanel.style.left = "18px";
    uiPanel.style.top = "18px";
    uiPanel.style.bottom = "auto";
    uiPanel.style.right = "auto";
    uiPanel.style.width = "380px";
    uiPanel.style.height = "auto";
    uiPanel.style.maxWidth = "90vw";
    uiPanel.style.maxHeight = "90vh";
  }
}
setPanelInitialPosition();
window.addEventListener('resize', setPanelInitialPosition);

(function() {
  let uiPanel = document.getElementById('ui-panel');
  let dragHandle = document.getElementById('ui-drag-handle');
  let resizeHandle = document.getElementById('ui-resize-handle');
  let dragging = false, offsetX = 0, offsetY = 0;
  let resizing = false, resizeStartX = 0, resizeStartY = 0, panelStartW = 0, panelStartH = 0;
  let dragRAF = null;
  if(isMobile()) {
    let collapsed = false;
    dragHandle.addEventListener('click', function() {
      collapsed = !collapsed;
      if(collapsed) {
        uiPanel.style.transform = "translateY(85%)";
        uiPanel.style.opacity = "0.27";
      } else {
        uiPanel.style.transform = "translateY(0)";
        uiPanel.style.opacity = "1";
      }
    });
    dragHandle.style.cursor = "pointer";
  } else {
    dragHandle.addEventListener('mousedown', function(e) {
      dragging = true;
      uiPanel.classList.add('dragging');
      let rect = uiPanel.getBoundingClientRect();
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
      e.preventDefault();
      e.stopPropagation();
    });
    document.addEventListener('mousemove', function(e) {
      if (resizing) {
        let w = Math.max(260, Math.min(window.innerWidth-10, panelStartW + (e.clientX-resizeStartX)));
        let h = Math.max(120, Math.min(window.innerHeight-10, panelStartH + (e.clientY-resizeStartY)));
        uiPanel.style.width = w+"px";
        uiPanel.style.height = h+"px";
        return;
      }
      if (!dragging) return;
      if (dragRAF) return;
      dragRAF = requestAnimationFrame(function() {
        dragRAF = null;
        let nx = e.clientX - offsetX;
        let ny = e.clientY - offsetY;
        nx = Math.max(0, Math.min(window.innerWidth-uiPanel.offsetWidth, nx));
        ny = Math.max(0, Math.min(window.innerHeight-uiPanel.offsetHeight, ny));
        uiPanel.style.left = nx + "px";
        uiPanel.style.top = ny + "px";
      });
    });
    document.addEventListener('mouseup', function() {
      if (dragging) {
        dragging = false;
        uiPanel.classList.remove('dragging');
      }
      if (resizing) {
        resizing = false;
        uiPanel.classList.remove('resizing');
      }
    });
    dragHandle.addEventListener('click', e=>e.stopPropagation());
    resizeHandle.addEventListener('mousedown', function(e){
      resizing = true;
      panelStartW = uiPanel.offsetWidth;
      panelStartH = uiPanel.offsetHeight;
      resizeStartX = e.clientX;
      resizeStartY = e.clientY;
      uiPanel.classList.add('resizing');
      e.preventDefault();
      e.stopPropagation();
    });
  }
  uiPanel.addEventListener('mousedown', e => e.stopPropagation());
  // 显示/隐藏面板
  let panelHideBtn = document.getElementById('panel-hide-btn');
  let panelShowBtn = document.getElementById('panel-show-btn');
  panelHideBtn.onclick = function() {
    uiPanel.classList.add('hidden');
    panelShowBtn.style.display = "";
  };
  panelShowBtn.onclick = function() {
    uiPanel.classList.remove('hidden');
    panelShowBtn.style.display = "none";
  };
  // 面板自动半透明
  let panelTimer = null;
  let setInactive = function() {
    if (!uiPanel.classList.contains('hidden')) uiPanel.classList.add('inactive');
  };
  let setActive = function() {
    uiPanel.classList.remove('inactive');
    if(panelTimer) clearTimeout(panelTimer);
    panelTimer = setTimeout(setInactive, 2500);
  };
  uiPanel.addEventListener('mouseenter', setActive);
  uiPanel.addEventListener('mousemove', setActive);
  uiPanel.addEventListener('mouseleave', setInactive);
  setTimeout(setInactive, 3000);
})();

// ========== Matter.js 物理主逻辑 ==========
const { Engine, Render, Runner, World, Bodies, Body, Constraint, Composite, Composites, Events, Mouse, MouseConstraint, Vertices, Query } = Matter;
let engine = Engine.create(), world = engine.world;
let bodies = [], constraints = [], composites = [];
let currentColor = "#00aaff", isPaused = false, currentShape = "rectangle";
let uiPanel = document.getElementById('ui-panel');
let bgColor = "#ffffff";
const canvas = document.getElementById('world-canvas');
const selectionCanvas = document.getElementById('selection-canvas');
let selectedBody = null, selectedBodies = [], groupMode = false;
let energyEnabled = false;

function resizeCanvas() {
  const cssWidth = window.innerWidth;
  const cssHeight = window.innerHeight;
  const dpr = window.devicePixelRatio || 1;
  [canvas, selectionCanvas].forEach(cv=>{
    cv.width = cssWidth * dpr;
    cv.height = cssHeight * dpr;
    cv.style.width = cssWidth + "px";
    cv.style.height = cssHeight + "px";
  });
  render.options.width = canvas.width;
  render.options.height = canvas.height;
  render.canvas.width = canvas.width;
  render.canvas.height = canvas.height;
  render.canvas.style.width = cssWidth + "px";
  render.canvas.style.height = cssHeight + "px";
  setBgColor(bgColor);
}
window.addEventListener('resize', resizeCanvas);

const render = Render.create({
  canvas: canvas,
  engine: engine,
  options: {
    width: window.innerWidth * (window.devicePixelRatio || 1),
    height: window.innerHeight * (window.devicePixelRatio || 1),
    wireframes: false,
    background: bgColor,
    pixelRatio: window.devicePixelRatio,
  }
});
let energyToggle = document.getElementById('energy-toggle');
energyToggle.onchange = function() {
  energyEnabled = this.checked;
};
function customRender() {
  let ctx = render.context;
  if(energyEnabled) {
    for(let b of bodies) {
      if(b.isStatic) continue;
      ctx.save();
      let vx = b.velocity.x, vy = b.velocity.y;
      let m = b.mass;
      let ke = 0.5 * m * (vx*vx+vy*vy);
      ctx.font = "bold 15px Arial";
      ctx.fillStyle = "#e44";
      ctx.fillText("KE:"+ke.toFixed(2), b.position.x-25, b.position.y-18);
      ctx.beginPath();
      ctx.arc(b.position.x, b.position.y, 4, 0, 2*Math.PI);
      ctx.fillStyle = "#1f6";
      ctx.fill();
      ctx.restore();
    }
  }
  if(selectedBody && !groupMode) {
    ctx.save();
    ctx.beginPath();
    let ps = selectedBody.vertices;
    ctx.moveTo(ps[0].x, ps[0].y);
    for(let i=1;i<ps.length;i++) ctx.lineTo(ps[i].x, ps[i].y);
    ctx.closePath();
    ctx.lineWidth = 4;
    ctx.strokeStyle = "#ff0";
    ctx.stroke();
    ctx.restore();
  }
  if(selectedBodies.length && groupMode) {
    for(let sb of selectedBodies) {
      ctx.save();
      ctx.beginPath();
      let ps = sb.vertices;
      ctx.moveTo(ps[0].x, ps[0].y);
      for(let i=1;i<ps.length;i++) ctx.lineTo(ps[i].x, ps[i].y);
      ctx.closePath();
      ctx.lineWidth = 4;
      ctx.strokeStyle = "#ff0";
      ctx.stroke();
      ctx.restore();
    }
  }
  requestAnimationFrame(customRender);
}
requestAnimationFrame(customRender);
Render.run(render);

function setBgColor(color) {
  bgColor = color;
  render.options.background = bgColor;
  render.canvas.style.background = bgColor;
  Render.stop(render); Render.run(render);
}
document.getElementById('bg-color-picker').oninput = e => setBgColor(e.target.value);
setBgColor(bgColor);

const runner = Runner.create();
Runner.run(runner, engine);

function createBounds() {
  const dpr = window.devicePixelRatio || 1;
  const w = window.innerWidth * dpr, h = window.innerHeight * dpr;
  const thickness = 60 * dpr;
  return [
    Bodies.rectangle(w/2, h + thickness/2, w, thickness, { isStatic: true, render:{ fillStyle: "#333" } }),
    Bodies.rectangle(w/2, -thickness/2, w, thickness, { isStatic: true, render:{ fillStyle: "#333" } }),
    Bodies.rectangle(-thickness/2, h/2, thickness, h, { isStatic: true, render:{ fillStyle: "#333" } }),
    Bodies.rectangle(w+thickness/2, h/2, thickness, h, { isStatic: true, render:{ fillStyle: "#333" } }),
  ];
}
let bounds = createBounds();
World.add(world, bounds);
window.addEventListener('resize', () => {
  World.remove(world, bounds);
  bounds = createBounds();
  World.add(world, bounds);
});

const mouse = Mouse.create(render.canvas);
let lastPointerDownWasOnBody = false;
const mouseConstraint = MouseConstraint.create(engine, {
  mouse: mouse,
  constraint: { stiffness: 0.18, render: { visible: false } }
});
World.add(world, mouseConstraint);
Events.on(mouseConstraint, 'mousedown', function(e) {
  lastPointerDownWasOnBody = !!mouseConstraint.body;
});

const batchCheckbox = document.getElementById('batch-mode');
function updateSelectionCanvasEvents() {
  if (batchCheckbox.checked) {
    selectionCanvas.style.pointerEvents = "auto";
  } else {
    selectionCanvas.style.pointerEvents = "none";
  }
}
batchCheckbox.addEventListener('change', updateSelectionCanvasEvents);
updateSelectionCanvasEvents();

let batchSize = 30;
let isSelecting = false;
let selectStart = null, selectEnd = null;
const batchSizeInput = document.getElementById('batch-size');
batchSizeInput.oninput = e => batchSize = Math.max(10, Math.min(100, parseInt(e.target.value) || 30));

function clearSelectionRect() {
  const ctx = selectionCanvas.getContext('2d');
  ctx.clearRect(0,0,selectionCanvas.width,selectionCanvas.height);
}

function drawSelectionRect() {
  clearSelectionRect();
  if (!isSelecting || !selectStart || !selectEnd) return;
  const ctx = selectionCanvas.getContext('2d');
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  const x = Math.min(selectStart.x, selectEnd.x);
  const y = Math.min(selectStart.y, selectEnd.y);
  const w = Math.abs(selectEnd.x - selectStart.x);
  const h = Math.abs(selectEnd.y - selectStart.y);
  ctx.strokeStyle = "rgba(90,180,255,0.85)";
  ctx.lineWidth = 3;
  ctx.strokeRect(x,y,w,h);
  ctx.fillStyle = "rgba(90,180,255,0.15)";
  ctx.fillRect(x,y,w,h);
  ctx.restore();
}

selectionCanvas.addEventListener('mousedown', function(e) {
  if (!batchCheckbox.checked && !groupMode) return;
  isSelecting = true;
  const rect = selectionCanvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  selectStart = {
    x: (e.clientX - rect.left) * dpr,
    y: (e.clientY - rect.top) * dpr
  };
  selectEnd = {...selectStart};
  drawSelectionRect();
});
selectionCanvas.addEventListener('mousemove', function(e) {
  if (!isSelecting) return;
  const rect = selectionCanvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  selectEnd = {
    x: (e.clientX - rect.left) * dpr,
    y: (e.clientY - rect.top) * dpr
  };
  drawSelectionRect();
});
selectionCanvas.addEventListener('mouseup', function(e) {
  if (!isSelecting) return;
  isSelecting = false;
  drawSelectionRect();
  const x0 = Math.min(selectStart.x, selectEnd.x), x1 = Math.max(selectStart.x, selectEnd.x);
  const y0 = Math.min(selectStart.y, selectEnd.y), y1 = Math.max(selectStart.y, selectEnd.y);
  const canvasW = canvas.width, canvasH = canvas.height;
  if(batchCheckbox.checked) {
    for(let x = x0 + batchSize/2; x + batchSize/2 <= x1; x += batchSize) {
      for(let y = y0 + batchSize/2; y + batchSize/2 <= y1; y += batchSize) {
        if(x - batchSize/2 < 0 || x + batchSize/2 > canvasW || y - batchSize/2 < 0 || y + batchSize/2 > canvasH) continue;
        addShapeAt(x, y, "rectangle", batchSize, batchSize);
      }
    }
  } else if(groupMode) {
    selectedBodies = [];
    let selAABB = {min:{x:x0,y:y0},max:{x:x1,y:y1}};
    for(let b of bodies) {
      if(b.isStatic) continue;
      let bb = b.bounds;
      if(bb.max.x<selAABB.min.x || bb.min.x>selAABB.max.x || bb.max.y<selAABB.min.y || bb.min.y>selAABB.max.y) continue;
      selectedBodies.push(b);
    }
    document.getElementById('delete-btn').disabled = selectedBodies.length==0;
  }
  clearSelectionRect();
});
selectionCanvas.addEventListener('mouseleave', function() {
  if(isSelecting) {
    isSelecting = false;
    clearSelectionRect();
  }
});

canvas.addEventListener('mouseup', function(e) {
  if(document.getElementById('batch-mode').checked) return;
  let uiRect = uiPanel.getBoundingClientRect();
  if (
    e.clientX >= uiRect.left && e.clientX <= uiRect.right &&
    e.clientY >= uiRect.top && e.clientY <= uiRect.bottom
  ) return;
  if (lastPointerDownWasOnBody) {
    lastPointerDownWasOnBody = false;
    return;
  }
  if(groupMode) return;
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const x = (e.clientX - rect.left) * dpr;
  const y = (e.clientY - rect.top) * dpr;
  addShapeAt(x, y);
});

const paramList = {
  rectangle: [
    {name: "width", label: "宽", type: "number", min: 20, max: 300, value: 120},
    {name: "height", label: "高", type: "number", min: 20, max: 200, value: 70},
    {name: "angle", label: "角度", type: "number", min: 0, max: 360, value: 0, step:1},
    {name: "density", label: "密度", type: "number", min: 0.0001, max: 0.2, value:0.001, step:0.0001},
    {name: "friction", label: "摩擦", type: "number", min: 0, max: 1, value:0.1, step:0.01},
    {name: "restitution", label: "弹性", type: "number", min: 0, max: 1, value:0.3, step:0.01},
    {name: "alpha", label: "透明度", type: "number", min: 0, max: 1, value: 1, step: 0.01}
  ],
  circle: [
    {name: "radius", label: "半径", type: "number", min: 10, max: 120, value: 45},
    {name: "density", label: "密度", type: "number", min: 0.0001, max: 0.2, value:0.001, step:0.0001},
    {name: "friction", label: "摩擦", type: "number", min: 0, max: 1, value:0.05, step:0.01},
    {name: "restitution", label: "弹性", type: "number", min: 0, max: 1, value:0.45, step:0.01},
    {name: "alpha", label: "透明度", type: "number", min: 0, max: 1, value: 1, step: 0.01}
  ],
  polygon: [
    {name: "sides", label: "边数", type: "number", min:3, max:12, value:5, step:1},
    {name: "radius", label: "半径", type: "number", min:10, max:80, value:36},
    {name: "density", label: "密度", type: "number", min: 0.0001, max: 0.2, value:0.001, step:0.0001},
    {name: "friction", label: "摩擦", type: "number", min: 0, max: 1, value:0.08, step:0.01},
    {name: "restitution", label: "弹性", type: "number", min: 0, max: 1, value:0.4, step:0.01},
    {name: "alpha", label: "透明度", type: "number", min: 0, max: 1, value: 1, step: 0.01}
  ],
  trapezoid: [
    {name: "width", label: "上宽", type: "number", min:30, max:200, value:120},
    {name: "height", label: "高", type: "number", min:20, max:120, value:60},
    {name: "slope", label: "斜率", type: "number", min:0.2, max:1, value:0.5, step:0.01},
    {name: "density", label: "密度", type: "number", min: 0.0001, max: 0.2, value:0.001, step:0.0001},
    {name: "friction", label: "摩擦", type: "number", min: 0, max: 1, value:0.12, step:0.01},
    {name: "restitution", label: "弹性", type: "number", min: 0, max: 1, value:0.38, step:0.01},
    {name: "alpha", label: "透明度", type: "number", min: 0, max: 1, value: 1, step: 0.01}
  ],
  fromVertices: [
    {name: "scale", label: "缩放", type: "number", min:0.2, max:2, value:1, step:0.01},
    {name: "density", label: "密度", type: "number", min: 0.0001, max: 0.2, value:0.001, step:0.0001},
    {name: "friction", label: "摩擦", type: "number", min: 0, max: 1, value:0.15, step:0.01},
    {name: "restitution", label: "弹性", type: "number", min: 0, max: 1, value:0.36, step:0.01},
    {name: "alpha", label: "透明度", type: "number", min: 0, max: 1, value: 1, step: 0.01}
  ],
  composite: [
    {name: "balls", label: "球数", type: "number", min:3, max:9, value:5, step:1},
    {name: "radius", label: "球半径", type: "number", min:8, max:40, value:20},
    {name: "distance", label: "距离", type: "number", min:60, max:300, value:120},
    {name: "density", label: "密度", type: "number", min: 0.0001, max: 0.2, value:0.001, step:0.0001}
  ],
  constraint: [
    {name: "len", label: "长度", type: "number", min:30, max:300, value:120},
    {name: "radius", label: "球半径", type: "number", min:10, max:50, value:25},
    {name: "stiffness", label: "刚度", type: "number", min:0.01, max:1, value:0.06, step:0.01},
    {name: "density", label: "密度", type: "number", min: 0.0001, max: 0.2, value:0.001, step:0.0001}
  ],
  softbody: [
    {name: "columns", label: "列数", type: "number", min:2, max:10, value:7, step:1},
    {name: "rows", label: "行数", type: "number", min:2, max:8, value:3, step:1},
    {name: "xgap", label: "横间隔", type: "number", min:2, max:30, value:10},
    {name: "ygap", label: "纵间隔", type: "number", min:2, max:30, value:10},
    {name: "radius", label: "球半径", type: "number", min:6, max:30, value:10},
    {name: "density", label: "密度", type: "number", min: 0.0001, max: 0.2, value:0.001, step:0.0001}
  ]
};
const paramHelpTxt = {
  rectangle: "矩形可设置宽高、角度、密度、摩擦、弹性、透明度。",
  circle: "圆形可设置半径、密度、摩擦、弹性、透明度。",
  polygon: "多边形可设置边数、半径、密度、摩擦、弹性、透明度。",
  trapezoid: "梯形可设置宽、高、斜率、密度、摩擦、弹性、透明度。",
  fromVertices: "自定义多边形为五角星，可缩放、透明度。",
  composite: "牛顿摆复合体，可设置球数、半径、距离、密度。",
  constraint: "连杆约束为两个球之间的弹簧，可设置长度、球半径、刚度。",
  softbody: "软体网格，可设置行列、间隔、球半径、密度。"
};
function hexToRgba(hex, alpha) {
  let r = parseInt(hex.slice(1,3),16);
  let g = parseInt(hex.slice(3,5),16);
  let b = parseInt(hex.slice(5,7),16);
  return `rgba(${r},${g},${b},${alpha})`;
}
function renderParamFields(type) {
  let params = paramList[type] || [];
  let pf = document.getElementById('param-fields');
  pf.innerHTML = "";
  params.forEach(p => {
    let input = document.createElement('input');
    input.type = p.type;
    input.id = "param-" + p.name;
    input.value = p.value;
    if(p.min !== undefined) input.min = p.min;
    if(p.max !== undefined) input.max = p.max;
    if(p.step !== undefined) input.step = p.step;
    let label = document.createElement('label');
    label.innerText = p.label;
    label.htmlFor = input.id;
    pf.appendChild(label);
    pf.appendChild(input);
  });
  document.getElementById('param-help').innerText = paramHelpTxt[type] || "";
}
renderParamFields(currentShape);
document.getElementById('shape-type').onchange = function() {
  currentShape = this.value;
  renderParamFields(currentShape);
};
function getField(name, type=null) {
  let v = document.getElementById('param-' + name);
  if(!v) return undefined;
  if(type==="int") return parseInt(v.value);
  if(type==="float") return parseFloat(v.value);
  return v.value ? Number(v.value) : undefined;
}
function addShapeAt(x, y, forceType = null, forceW = null, forceH = null) {
  let type = forceType || document.getElementById('shape-type').value;
  let color = document.getElementById('color-picker').value;
  let shape, params = paramList[type] || [], opt = {};
  params.forEach(p=>{ opt[p.name] = getField(p.name); });
  let alpha = (typeof opt.alpha === "number" && !isNaN(opt.alpha)) ? opt.alpha : 1;
  let fillColor = hexToRgba(color, alpha);
  if(type==="rectangle" || forceType==="rectangle") {
    let width = forceW || opt.width;
    let height = forceH || opt.height;
    let angle = (opt.angle||0) * Math.PI/180;
    let density = opt.density||0.001, friction = opt.friction||0.1, restitution = opt.restitution||0.3;
    shape = Bodies.rectangle(x, y, width, height, {
      angle: angle,
      density: density, friction: friction, restitution: restitution,
      render: { fillStyle: fillColor }
    });
    bodies.push(shape); World.add(world, shape);
    return shape;
  } else if(type==="circle") {
    shape = Bodies.circle(x, y, opt.radius, {
      density: opt.density, friction: opt.friction, restitution: opt.restitution,
      render: { fillStyle: fillColor },
    });
    bodies.push(shape); World.add(world, shape);
    return shape;
  } else if(type==="polygon") {
    shape = Bodies.polygon(x, y, Math.max(3,opt.sides), opt.radius, {
      density: opt.density, friction: opt.friction, restitution: opt.restitution,
      render: { fillStyle: fillColor }
    });
    bodies.push(shape); World.add(world, shape);
    return shape;
  } else if(type==="trapezoid") {
    shape = Bodies.trapezoid(x, y, opt.width, opt.height, opt.slope, {
      density: opt.density, friction: opt.friction, restitution: opt.restitution,
      render: { fillStyle: fillColor }
    });
    bodies.push(shape); World.add(world, shape);
    return shape;
  } else if(type==="fromVertices") {
    let verts = Vertices.fromPath("0 30 12 12 30 0 12 -12 0 -30 -12 -12 -30 0 -12 12");
    let scaled = verts.map(v => ({x: v.x*opt.scale, y: v.y*opt.scale}));
    shape = Bodies.fromVertices(x, y, scaled, {
      density: opt.density, friction: opt.friction, restitution: opt.restitution,
      render: { fillStyle: fillColor }
    }, true);
    bodies.push(shape); World.add(world, shape);
    return shape;
  } else if(type==="composite") {
    let cradle = Composites.newtonsCradle(x, y, Math.max(3,opt.balls), opt.radius, opt.distance);
    Composite.allBodies(cradle).forEach(b=>{
      b.render.fillStyle = color;
      b.density = opt.density;
    });
    composites.push(cradle); World.add(world, cradle);
  } else if(type==="constraint") {
    let ballA = Bodies.circle(x, y, opt.radius, { density: opt.density, render: { fillStyle: color } });
    let ballB = Bodies.circle(x+opt.len, y, opt.radius, { density: opt.density, render: { fillStyle: color } });
    let link = Constraint.create({
      bodyA: ballA, bodyB: ballB,
      stiffness: opt.stiffness, length: opt.len,
      render: { strokeStyle: "#fff", lineWidth: 3 }
    });
    bodies.push(ballA, ballB); constraints.push(link);
    World.add(world, [ballA, ballB, link]);
  } else if(type==="softbody") {
    let soft = Composites.softBody(x, y, Math.max(2,opt.columns), Math.max(2,opt.rows), opt.xgap, opt.ygap, false, opt.radius,
      function(xx,yy) {
        return Bodies.circle(xx,yy,opt.radius,{density: opt.density, render:{fillStyle: color}});
      });
    composites.push(soft); World.add(world, soft);
  }
  return null;
}
document.getElementById('color-picker').oninput = e => { currentColor = e.target.value; };
document.getElementById('gravity-slider').oninput = function() {
  const g = parseFloat(this.value);
  engine.world.gravity.y = g;
  document.getElementById('gravity-value').innerText = g.toFixed(2);
};
document.getElementById('gravity-value').innerText = engine.world.gravity.y.toFixed(2);
document.getElementById('pause-btn').onclick = () => {
  if (!isPaused) {
    Runner.stop(runner);
    isPaused = true;
    document.getElementById('pause-btn').disabled = true;
    document.getElementById('resume-btn').disabled = false;
  }
};
document.getElementById('resume-btn').onclick = () => {
  if (isPaused) {
    Runner.run(runner, engine);
    isPaused = false;
    document.getElementById('pause-btn').disabled = false;
    document.getElementById('resume-btn').disabled = true;
  }
};
function clearAllBodies() {
  bodies.forEach(b => World.remove(world, b));
  constraints.forEach(c => World.remove(world, c));
  composites.forEach(cmp => World.remove(world, cmp));
  bodies = [];
  constraints = [];
  composites = [];
  selectedBody = null;
  selectedBodies = [];
  document.getElementById('delete-btn').disabled = true;
}
document.getElementById('reset-btn').onclick = clearAllBodies;
document.getElementById('clear-btn').onclick = clearAllBodies;

let groupModeCheckbox = document.getElementById('group-mode');
groupModeCheckbox.onchange = function() {
  groupMode = this.checked;
  selectedBodies = [];
  selectedBody = null;
  document.getElementById('delete-btn').disabled = true;
};
document.getElementById('delete-btn').onclick = function() {
  if(groupMode && selectedBodies.length) {
    for(let b of selectedBodies) {
      World.remove(world, b);
      let idx = bodies.indexOf(b); if(idx!==-1) bodies.splice(idx,1);
    }
    selectedBodies = [];
    document.getElementById('delete-btn').disabled = true;
  } else if(selectedBody) {
    World.remove(world, selectedBody);
    let idx = bodies.indexOf(selectedBody); if(idx!==-1) bodies.splice(idx,1);
    selectedBody = null;
    document.getElementById('delete-btn').disabled = true;
  }
};

let attrModalBg = document.getElementById('attr-modal-bg');
let attrModal = document.getElementById('attr-modal');
let attrFields = document.getElementById('attr-fields');
let attrModalClose = document.getElementById('attr-modal-close');
let attrDelBtn = document.getElementById('attr-del-btn');
let attrForm = document.getElementById('attr-form');
function showAttrModal(body) {
  attrFields.innerHTML = "";
  let pos = body.position;
  let angle = body.angle || 0;
  let vx = body.velocity ? body.velocity.x : 0, vy = body.velocity ? body.velocity.y : 0;
  let mass = body.mass || 1;
  let attrs = [
    {label:"X", id:"attr-x", value:pos.x, type:"number"},
    {label:"Y", id:"attr-y", value:pos.y, type:"number"},
    {label:"角度", id:"attr-angle", value: (angle*180/Math.PI).toFixed(1), type:"number"},
    {label:"速度X", id:"attr-vx", value: vx, type:"number"},
    {label:"速度Y", id:"attr-vy", value: vy, type:"number"},
    {label:"质量", id:"attr-mass", value: mass, type:"number"}
  ];
  for(let a of attrs) {
    let label = document.createElement('label');
    label.innerText = a.label+":";
    let input = document.createElement('input');
    input.type = a.type;
    input.value = a.value;
    input.id = a.id;
    label.appendChild(input);
    attrFields.appendChild(label);
  }
  attrModalBg.style.display = "block";
  attrModal.style.display = "block";
  attrModalBody = body;
}
function hideAttrModal() {
  attrModalBg.style.display = "none";
  attrModal.style.display = "none";
}
attrModalClose.onclick = hideAttrModal;
attrModalBg.onclick = hideAttrModal;
attrForm.onsubmit = function(e) {e.preventDefault();};
attrDelBtn.onclick = function() {
  if(attrModalBody) {
    World.remove(world, attrModalBody);
    let idx = bodies.indexOf(attrModalBody); if(idx!==-1) bodies.splice(idx,1);
    hideAttrModal();
    selectedBody = null;
    document.getElementById('delete-btn').disabled = true;
  }
}
let attrModalBody = null;
attrForm.addEventListener('change', function(e){
  if(!attrModalBody) return;
  let x = parseFloat(document.getElementById('attr-x').value);
  let y = parseFloat(document.getElementById('attr-y').value);
  let angle = parseFloat(document.getElementById('attr-angle').value) * Math.PI/180;
  let vx = parseFloat(document.getElementById('attr-vx').value);
  let vy = parseFloat(document.getElementById('attr-vy').value);
  let mass = parseFloat(document.getElementById('attr-mass').value);
  Body.setPosition(attrModalBody, {x:x, y:y});
  Body.setAngle(attrModalBody, angle);
  Body.setVelocity(attrModalBody, {x:vx, y:vy});
  attrModalBody.mass = mass;
});

let lastHoverBody = null;
canvas.addEventListener('mousemove', function(e) {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const x = (e.clientX - rect.left) * dpr;
  const y = (e.clientY - rect.top) * dpr;
  let found = Query.point(bodies, {x:x,y:y}).find(b=>!b.isStatic);
  if(lastHoverBody && lastHoverBody!==found) {
    lastHoverBody.render.strokeStyle = null;
    lastHoverBody.render.lineWidth = null;
  }
  if(found && found!==lastHoverBody) {
    found.render.strokeStyle = "#0ff";
    found.render.lineWidth = 4;
  }
  lastHoverBody = found;
});
canvas.addEventListener('mousedown', function(e){
  if(e.button!==0) return;
  if(groupMode) return;
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const x = (e.clientX - rect.left) * dpr;
  const y = (e.clientY - rect.top) * dpr;
  let found = Query.point(bodies, {x:x,y:y}).find(b=>!b.isStatic);
  if(found) {
    selectedBody = found;
    document.getElementById('delete-btn').disabled = false;
  } else {
    selectedBody = null;
    document.getElementById('delete-btn').disabled = true;
  }
});
canvas.addEventListener('contextmenu', function(e){
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const x = (e.clientX - rect.left) * dpr;
  const y = (e.clientY - rect.top) * dpr;
  let found = Query.point(bodies, {x:x,y:y}).find(b=>!b.isStatic);
  if(found) {
    showAttrModal(found);
  }
  return false;
});
document.getElementById('save-btn').onclick = function() {
  let state = {
    bodies: bodies.filter(b=>!b.isStatic).map(b=>{
      let shape = "fromVertices";
      if(b.label.indexOf('Rectangle')!==-1) shape = "rectangle";
      else if(b.label.indexOf('Circle')!==-1) shape = "circle";
      else if(b.label.indexOf('Polygon')!==-1) shape = "polygon";
      else if(b.label.indexOf('Trapezoid')!==-1) shape = "trapezoid";
      return {
        shape: shape,
        position: b.position,
        angle: b.angle,
        velocity: b.velocity,
        mass: b.mass,
        render: b.render,
        params: {
          width: b.bounds.max.x-b.bounds.min.x,
          height: b.bounds.max.y-b.bounds.min.y,
          radius: (b.circleRadius||0)
        }
      };
    })
  };
  let blob = new Blob([JSON.stringify(state,null,2)],{type:"application/json"});
  let url = URL.createObjectURL(blob);
  let a = document.createElement('a');
  a.href = url; a.download = "scene.json";
  a.click();
  URL.revokeObjectURL(url);
};
document.getElementById('load-btn').onclick = function() {
  document.getElementById('file-input').click();
};
document.getElementById('file-input').onchange = function(e) {
  let f = e.target.files[0];
  if(!f) return;
  let reader = new FileReader();
  reader.onload = function(ev) {
    let state = JSON.parse(ev.target.result);
    clearAllBodies();
    for(let b of state.bodies) {
      let {shape,position,angle,velocity,render,params} = b;
      let inst = null;
      if(shape==="rectangle") inst = Bodies.rectangle(position.x, position.y, params.width, params.height, {angle,render});
      else if(shape==="circle") inst = Bodies.circle(position.x, position.y, params.radius, {angle,render});
      else if(shape==="polygon") inst = Bodies.polygon(position.x, position.y, 5, params.radius, {angle,render});
      else if(shape==="trapezoid") inst = Bodies.trapezoid(position.x, position.y, params.width, params.height, 0.5, {angle,render});
      else if(shape==="fromVertices") inst = Bodies.fromVertices(position.x, position.y, Vertices.fromPath("0 30 12 12 30 0 12 -12 0 -30 -12 -12 -30 0 -12 12"), {angle,render}, true);
      if(inst) {
        World.add(world, inst);
        bodies.push(inst);
        Body.setVelocity(inst, velocity);
        inst.mass = b.mass;
      }
    }
  };
  reader.readAsText(f);
};
Events.on(mouseConstraint, 'startdrag', function(e) {
  if (e.body && !e.body.isStatic) {
    e.body.render.strokeStyle = "#fff";
    e.body.render.lineWidth = 4;
  }
});
Events.on(mouseConstraint, 'enddrag', function(e) {
  if (e.body && !e.body.isStatic) {
    e.body.render.strokeStyle = null;
    e.body.render.lineWidth = null;
  }
});
resizeCanvas();
renderParamFields(currentShape);
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
selectionCanvas.addEventListener('mouseleave', function() {
  if(isSelecting) {
    isSelecting = false;
    clearSelectionRect();
  }
});
  </script>
</body>
</html>
