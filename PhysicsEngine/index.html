<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>MatterXXenosMC|2DEngine</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100vw; height: 100vh;
      background: #eef;
      overflow: hidden;
      font-family: 'Segoe UI', 'Arial', sans-serif;
      -webkit-user-select: none; user-select: none;
      touch-action: none;
    }
    #appcontainer {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
    }
    #topbar {
      width: 100vw;
      max-width: 900px;
      margin: 8px auto 0 auto;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      padding: 0 10px;
    }
    #fps {
      font-size: 14px;
      color: #444;
      background: #fff7;
      padding: 3px 11px 3px 11px;
      border-radius: 4px;
      font-family: monospace;
      min-width: 66px;
    }
    #toolbar {
      width: 100vw;
      overflow-x: auto;
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-start;
      background: #dde3ef;
      padding: 6px 0 8px 0;
      scrollbar-width: thin;
      border-top: 1.5px solid #b2c6e6;
      border-bottom: 1.5px solid #b2c6e6;
    }
    #toolbar button, #toolbar input[type=button] {
      padding: 13px 15px;
      border: none;
      border-radius: 7px;
      background: #e1eaf7;
      color: #222;
      font-size: 17px;
      cursor: pointer;
      margin: 0 0 0 8px;
      min-width: 62px;
      transition: background 0.18s;
      outline: none;
      flex-shrink: 0;
    }
    #toolbar button.active {
      background: #3678e2;
      color: #fff;
    }
    #toolbar input[type=button] {
      background: #db6565;
      color: #fff;
      font-weight: bold;
      margin-left: 12px;
    }
    #scene-wrap {
      flex: 1 1 0;
      min-height: 0;
      min-width: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #dde6ee;
      position: relative;
      overflow: hidden;
      touch-action: none;
    }
    #scene {
      display: block;
      width: 96vw;
      height: 63vw;
      max-width: 900px;
      max-height: 74vw;
      min-width: 210px;
      min-height: 170px;
      border-radius: 8px;
      background: #eef;
      border: 2.5px solid #8eb6e6;
      box-shadow: 0 1px 12px #aaa4;
      margin: 0 auto;
      touch-action: none;
    }
    #poly-modal-bg {
      position: fixed; left:0;top:0;width:100vw;height:100vh;
      background: #0007;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 99;
    }
    #poly-modal {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 32px #0006;
      padding: 10px 13px 10px 13px;
      min-width: 180px; min-height: 180px;
      display: flex; flex-direction: column; align-items: center;
    }
    #poly-title {
      font-size: 17px; font-weight: bold; color: #357; margin-bottom: 7px;
    }
    #poly-canvas {
      border: 2px solid #8eb6e6;
      background: #f5f8fd;
      border-radius: 7px;
      margin-bottom: 8px;
      display: block;
      box-shadow: 0 0 8px #bbb3;
      width: 170px;
      height: 170px;
      touch-action: none;
    }
    #poly-btns {
      display: flex;
      gap: 10px;
      margin-top: 8px;
      width: 100%;
      justify-content: center;
    }
    #poly-btns button {
      background: #3678e2;
      color: #fff;
      border: none;
      border-radius: 5px;
      padding: 8px 17px;
      font-size: 15px;
      cursor: pointer;
      transition: background 0.15s;
    }
    #poly-btns button.secondary {
      background: #dde3ef;
      color: #223;
    }
    #poly-btns button:disabled {
      background: #bfcfdf;
      color: #888;
      cursor: not-allowed;
    }
    #poly-tip {
      font-size: 13px;
      color: #4a6;
      margin-bottom: 4px;
      margin-top: -1px;
      text-align: center;
    }
    @media (max-width: 600px) {
      #scene { width: 99vw; height: 56vw; min-height: 100px; }
      #poly-canvas { width: 120px; height: 120px; }
      #poly-title { font-size: 15px;}
    }
    @media (max-width: 380px) {
      #scene { min-width: 80vw; }
      #poly-canvas { width: 80px; height: 80px; }
      #poly-title { font-size: 13px;}
    }
  </style>
</head>
<body>
<div id="appcontainer">
  <div id="topbar">
    <span id="fps">FPS: --</span>
  </div>
  <div id="toolbar">
    <button data-shape="rectangle" class="active">矩形</button>
    <button data-shape="circle">圆形</button>
    <button data-shape="polygon3">三角形</button>
    <button data-shape="polygon4">正方形</button>
    <button data-shape="polygon5">五边形</button>
    <button data-shape="polygon6">六边形</button>
    <button data-shape="trapezoid">梯形</button>
    <button data-shape="star">星形</button>
    <button data-shape="compound">复合</button>
    <button id="poly-btn" data-shape="custompoly">多边形</button>
    <input type="button" id="clear-btn" value="清空">
  </div>
  <div id="scene-wrap">
    <canvas id="scene" width="345" height="210" tabindex="0"></canvas>
  </div>
</div>
<!-- 多边形绘制弹窗 -->
<div id="poly-modal-bg">
  <div id="poly-modal">
    <div id="poly-title">自定义多边形</div>
    <canvas id="poly-canvas" width="120" height="120"></canvas>
    <div id="poly-tip">点触添加点，长按撤销，双击闭合。完成后生成刚体。</div>
    <div id="poly-btns">
      <button id="poly-finish">完成</button>
      <button id="poly-cancel" class="secondary">取消</button>
      <button id="poly-reset" class="secondary">重置</button>
    </div>
  </div>
</div>
<script src="matter.js"></script>
<script>
const { Engine, Render, Runner, Composite, Bodies, Body, Vertices, Mouse, MouseConstraint, Events, Query } = Matter;

// ========== 画布自适应 ==========
const wrap = document.getElementById('scene-wrap');
const canvas = document.getElementById('scene');
function resizeCanvas() {
  // 宽高基于窗口
  let w = Math.floor(Math.max(210, Math.min(window.innerWidth * 0.98, 900)));
  let h = Math.floor(Math.max(130, Math.min(window.innerHeight * 0.56, 700)));
  canvas.width = w;
  canvas.height = h;
  return {w, h};
}
let {w:CANVAS_W, h:CANVAS_H} = resizeCanvas();
window.addEventListener('resize', function() {
  const r = resizeCanvas();
  CANVAS_W = r.w; CANVAS_H = r.h;
  render.options.width = CANVAS_W;
  render.options.height = CANVAS_H;
  Render.setPixelRatio(render, window.devicePixelRatio);
  Composite.remove(world, walls);
  walls = createWalls(CANVAS_W, CANVAS_H);
  Composite.add(world, walls);
});

// ========== 物理引擎 ==========
const engine = Engine.create();
const world = engine.world;
const render = Render.create({
  canvas: canvas,
  engine: engine,
  options: {
    width: CANVAS_W,
    height: CANVAS_H,
    wireframes: false,
    background: "#eef",
    hasBounds: false,
    pixelRatio: window.devicePixelRatio
  }
});
Render.run(render);
const runner = Runner.create();
Runner.run(runner, engine);

// ========== FPS ==========
let fps = 0, frameCount = 0, lastFpsUpdate = Date.now();
function updateFps() {
  frameCount++;
  const now = Date.now();
  if (now - lastFpsUpdate >= 500) {
    fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
    document.getElementById('fps').textContent = `FPS: ${fps}`;
    lastFpsUpdate = now;
    frameCount = 0;
  }
}
(function fpsLoop(){
  updateFps();
  requestAnimationFrame(fpsLoop);
})();

// ========== 墙体 ==========
const thickness = 40;
function createWalls(w, h) {
  let arr = [
    Bodies.rectangle(w/2, h-thickness/2, w, thickness, { isStatic: true, render: { fillStyle: "#aee" } }),
    Bodies.rectangle(w/2, thickness/2, w, thickness, { isStatic: true, render: { fillStyle: "#aee" } }),
    Bodies.rectangle(thickness/2, h/2, thickness, h, { isStatic: true, render: { fillStyle: "#aee" } }),
    Bodies.rectangle(w-thickness/2, h/2, thickness, h, { isStatic: true, render: { fillStyle: "#aee" } })
  ];
  arr.forEach(b => b.label = "wall");
  return arr;
}
let walls = createWalls(CANVAS_W, CANVAS_H);
Composite.add(world, walls);

// ========== 工具栏 ==========
const toolbar = document.getElementById('toolbar');
let currentShape = "rectangle";
toolbar.addEventListener('click', e => {
  if (e.target.tagName === "BUTTON") {
    toolbar.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
    e.target.classList.add('active');
    currentShape = e.target.getAttribute('data-shape');
    if (currentShape === 'custompoly') showPolyModal();
  }
});
document.getElementById('clear-btn').onclick = () => {
  Composite.allBodies(world)
    .filter(b => b.label !== "wall" && b.label !== 'Mouse Constraint')
    .forEach(b => Composite.remove(world, b));
};
function resetToolbarBtn() {
  toolbar.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
  toolbar.querySelector('button[data-shape="'+currentShape+'"]')?.classList.add('active');
}

// ========== 物体类型 ==========
function createBody(shape, x, y, customPolyVerts) {
  switch(shape) {
    case "rectangle":
      return Bodies.rectangle(x, y, 80, 40, { restitution: 0.4, friction: 0.2 });
    case "circle":
      return Bodies.circle(x, y, 32, { restitution: 0.82, friction: 0.09 });
    case "polygon3":
      return Bodies.polygon(x, y, 3, 38, { restitution: 0.6, friction: 0.2 });
    case "polygon4":
      return Bodies.polygon(x, y, 4, 36, { restitution: 0.5, friction: 0.2 });
    case "polygon5":
      return Bodies.polygon(x, y, 5, 32, { restitution: 0.5, friction: 0.2 });
    case "polygon6":
      return Bodies.polygon(x, y, 6, 30, { restitution: 0.5, friction: 0.2 });
    case "trapezoid":
      return Bodies.trapezoid(x, y, 92, 50, 0.6, { restitution: 0.45, friction: 0.16 });
    case "star": {
      const pts = [];
      const R1 = 40, R2 = 16;
      for (let i = 0; i < 10; ++i) {
        const ang = Math.PI/2 + i * Math.PI/5;
        const r = i % 2 === 0 ? R1 : R2;
        pts.push({ x: x + r * Math.cos(ang), y: y - r * Math.sin(ang) });
      }
      return Bodies.fromVertices(x, y, pts, { restitution: 0.6, friction: 0.2 });
    }
    case "compound": {
      const main = Bodies.circle(x, y, 32, { render: { fillStyle: '#fea' } });
      const left = Bodies.circle(x-22, y+28, 12, { render: { fillStyle: '#aef' } });
      const right = Bodies.circle(x+22, y+28, 12, { render: { fillStyle: '#faf' } });
      return Body.create({
        parts: [main, left, right],
        restitution: 0.7,
        friction: 0.15
      });
    }
    case "custompoly":
      if (!customPolyVerts) return null;
      const cx = customPolyVerts.reduce((a,b)=>a+b.x,0)/customPolyVerts.length;
      const cy = customPolyVerts.reduce((a,b)=>a+b.y,0)/customPolyVerts.length;
      const relVerts = customPolyVerts.map(p => ({ x: p.x-cx, y: p.y-cy }));
      return Bodies.fromVertices(x, y, [relVerts], { restitution: 0.55, friction: 0.18 });
    default:
      return Bodies.rectangle(x, y, 80, 40);
  }
}

// ========== PC/移动端事件统一 ==========
function getPointerXY(e, rect) {
  if (e.touches && e.touches.length) {
    return {
      x: e.touches[0].clientX - rect.left,
      y: e.touches[0].clientY - rect.top
    };
  } else {
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }
}

let isDragging = false, dragBody = null, dragOffset = { x:0, y:0 };

// ---- 主画布交互 ----
function findBodyAt(x, y) {
  return Query.point(Composite.allBodies(world), {x, y})
    .find(b => b.label !== "wall" && b.label !== "Mouse Constraint");
}

// 通用生成物体
function spawnBody(x, y) {
  if (currentShape === 'custompoly') return;
  if (findBodyAt(x, y)) return;
  const body = createBody(currentShape, x, y);
  if (body) Composite.add(world, body);
}

// 通用拖拽
function startDrag(x, y) {
  const found = findBodyAt(x, y);
  if (found) {
    isDragging = true;
    dragBody = found;
    dragOffset = { x: x - found.position.x, y: y - found.position.y };
    Body.setStatic(dragBody, true);
  }
}
function moveDrag(x, y) {
  if (isDragging && dragBody) {
    Body.setPosition(dragBody, { x: x - dragOffset.x, y: y - dragOffset.y });
    Body.setVelocity(dragBody, { x: 0, y: 0 });
    Body.setAngularVelocity(dragBody, 0);
  }
}
function endDrag() {
  if (isDragging && dragBody) {
    Body.setStatic(dragBody, false);
    dragBody = null;
    isDragging = false;
  }
}

// 通用删除
function removeBody(x, y) {
  const found = findBodyAt(x, y);
  if (found) Composite.remove(world, found);
}

// ---- 鼠标事件 ----
canvas.addEventListener('mousedown', function(e) {
  const rect = canvas.getBoundingClientRect();
  const {x, y} = getPointerXY(e, rect);
  if (e.button === 0) {
    spawnBody(x, y);
  } else if (e.button === 2) {
    startDrag(x, y);
    e.preventDefault();
  } else if (e.button === 1) {
    removeBody(x, y);
    e.preventDefault();
  }
});
canvas.addEventListener('mousemove', function(e) {
  if (!isDragging) return;
  const rect = canvas.getBoundingClientRect();
  const {x, y} = getPointerXY(e, rect);
  moveDrag(x, y);
});
canvas.addEventListener('mouseup', endDrag);
canvas.addEventListener('mouseleave', endDrag);
canvas.addEventListener('contextmenu', e => e.preventDefault());

// ---- 触摸事件 ----
let touchDrag = false, touchDragBody = null, touchStartXY = null, touchDragId = null, longTapTimer = null;
canvas.addEventListener('touchstart', function(e) {
  const rect = canvas.getBoundingClientRect();
  const {x, y} = getPointerXY(e, rect);
  touchStartXY = {x, y, time: Date.now()};
  // 生成物体（短触）
  longTapTimer = setTimeout(()=>{
    // 长按删除
    removeBody(x, y);
    longTapTimer = null;
  }, 500);
  // 拖拽
  touchDragBody = findBodyAt(x, y);
  if (touchDragBody) {
    touchDrag = true;
    dragBody = touchDragBody;
    dragOffset = { x: x - dragBody.position.x, y: y - dragBody.position.y };
    Body.setStatic(dragBody, true);
    touchDragId = e.changedTouches[0].identifier;
  }
  e.preventDefault();
}, {passive:false});
canvas.addEventListener('touchmove', function(e) {
  if (longTapTimer) { clearTimeout(longTapTimer); longTapTimer = null; }
  if (!touchDrag) return;
  let touch = null;
  for (let i=0;i<e.changedTouches.length;i++) {
    if (touchDragId==null || e.changedTouches[i].identifier === touchDragId) {
      touch = e.changedTouches[i]; break;
    }
  }
  if (!touch) return;
  const rect = canvas.getBoundingClientRect();
  const x = touch.clientX - rect.left;
  const y = touch.clientY - rect.top;
  moveDrag(x, y);
  e.preventDefault();
}, {passive:false});
canvas.addEventListener('touchend', function(e) {
  if (longTapTimer) {
    clearTimeout(longTapTimer);
    longTapTimer = null;
    // 这是普通轻点，生成物体
    if (touchStartXY && !findBodyAt(touchStartXY.x, touchStartXY.y))
      spawnBody(touchStartXY.x, touchStartXY.y);
  }
  endDrag();
  touchDrag = false;
  touchDragBody = null;
  touchDragId = null;
  touchStartXY = null;
}, {passive:false});

// ========== 鼠标拖拽约束（仅用于高亮）==========
const mouse = Mouse.create(canvas);
const mouseConstraint = MouseConstraint.create(engine, {
  mouse: mouse,
  constraint: { stiffness: 0.2, render: {visible: false} }
});
Composite.add(world, mouseConstraint);
render.mouse = mouse;

// ========== 鼠标悬停高亮 ==========
Events.on(render, 'afterRender', function() {
  const mousePos = mouse.position;
  const found = findBodyAt(mousePos.x, mousePos.y);
  if (found) {
    const ctx = render.context;
    ctx.save();
    ctx.strokeStyle = "#3b8eea";
    ctx.lineWidth = 3;
    if (found.circleRadius) {
      ctx.beginPath();
      ctx.arc(found.position.x, found.position.y, found.circleRadius+2, 0, 2*Math.PI);
      ctx.stroke();
    } else if (found.vertices) {
      ctx.beginPath();
      ctx.moveTo(found.vertices[0].x, found.vertices[0].y);
      for (let v of found.vertices) ctx.lineTo(v.x, v.y);
      ctx.closePath();
      ctx.stroke();
    }
    ctx.restore();
  }
});

// ========== 自定义多边形弹窗 ==========
const polyModalBg = document.getElementById('poly-modal-bg');
const polyModal = document.getElementById('poly-modal');
const polyCanvas = document.getElementById('poly-canvas');
const polyCtx = polyCanvas.getContext('2d');
let polyPoints = [];
let polyFinished = false;
function showPolyModal() {
  polyPoints = [];
  polyFinished = false;
  polyModalBg.style.display = 'flex';
  drawPolyCanvas();
}
function closePolyModal() {
  polyModalBg.style.display = 'none';
  resetToolbarBtn();
  currentShape = 'rectangle';
}
function drawPolyCanvas() {
  polyCtx.clearRect(0, 0, polyCanvas.width, polyCanvas.height);
  // 辅助线
  polyCtx.save();
  polyCtx.strokeStyle = '#eef';
  polyCtx.lineWidth = 1.2;
  for(let i=1;i<polyCanvas.width;i+=40){
    polyCtx.beginPath();
    polyCtx.moveTo(i,0); polyCtx.lineTo(i,polyCanvas.height); polyCtx.stroke();
    polyCtx.beginPath();
    polyCtx.moveTo(0,i); polyCtx.lineTo(polyCanvas.width,i); polyCtx.stroke();
  }
  polyCtx.restore();
  // 画多边形
  if (polyPoints.length) {
    polyCtx.save();
    polyCtx.beginPath();
    polyCtx.moveTo(polyPoints[0].x, polyPoints[0].y);
    for(let i=1;i<polyPoints.length;i++)
      polyCtx.lineTo(polyPoints[i].x, polyPoints[i].y);
    if (polyFinished && polyPoints.length>2) polyCtx.closePath();
    polyCtx.strokeStyle = '#3b8eea';
    polyCtx.lineWidth = 2.2;
    polyCtx.stroke();
    polyCtx.restore();
    // 画点
    polyCtx.save();
    polyPoints.forEach((p,i) => {
      polyCtx.beginPath();
      polyCtx.arc(p.x, p.y, 5, 0, 2*Math.PI);
      polyCtx.fillStyle = i==0 ? '#e63' : '#2d7';
      polyCtx.fill();
      polyCtx.strokeStyle = '#fff';
      polyCtx.lineWidth = 1.5;
      polyCtx.stroke();
    });
    polyCtx.restore();
  }
}
// 鼠标/触摸添加点、撤销、闭合
function polyAddPoint(x,y) { polyPoints.push({x,y}); drawPolyCanvas(); }
function polyUndoPoint() { polyPoints.pop(); drawPolyCanvas(); }
polyCanvas.addEventListener('mousedown', function(e) {
  if (polyFinished) return;
  const rect = polyCanvas.getBoundingClientRect();
  const {x, y} = getPointerXY(e, rect);
  if (e.button === 0) polyAddPoint(x, y);
  else if (e.button === 2) { polyUndoPoint(); e.preventDefault(); }
});
polyCanvas.addEventListener('dblclick', function(e) {
  if (polyPoints.length<3) return;
  polyFinished = true;
  drawPolyCanvas();
});
polyCanvas.addEventListener('contextmenu', e => e.preventDefault());
// 触摸多边形绘制
let polyTouchLongTapTimer = null;
polyCanvas.addEventListener('touchstart', function(e){
  if (polyFinished) return;
  const rect = polyCanvas.getBoundingClientRect();
  const {x, y} = getPointerXY(e, rect);
  polyTouchLongTapTimer = setTimeout(()=>{ polyUndoPoint(); polyTouchLongTapTimer=null; }, 430);
  polyCanvas._lastTouch = {x, y, time: Date.now()};
  e.preventDefault();
},{passive:false});
polyCanvas.addEventListener('touchmove', function(e){
  if(polyTouchLongTapTimer) { clearTimeout(polyTouchLongTapTimer); polyTouchLongTapTimer=null;}
},{passive:false});
polyCanvas.addEventListener('touchend', function(e){
  if(polyTouchLongTapTimer) {
    clearTimeout(polyTouchLongTapTimer); polyTouchLongTapTimer=null;
    const {x, y} = polyCanvas._lastTouch || {};
    if (typeof x === 'number' && typeof y === 'number') polyAddPoint(x, y);
  }
  polyCanvas._lastTouch = null;
},{passive:false});
// 移动端双击闭合
let polyLastTap=0;
polyCanvas.addEventListener('touchend', function(e){
  let now = Date.now();
  if(now-polyLastTap<320) {
    if (polyPoints.length>=3) { polyFinished=true; drawPolyCanvas(); }
    polyLastTap=0;
  } else { polyLastTap=now; }
},{passive:false});
document.getElementById('poly-finish').onclick = function(){
  if (polyPoints.length<3) {
    alert('需要至少3个点才能生成多边形');
    return;
  }
  const cx = polyPoints.reduce((a,b)=>a+b.x,0)/polyPoints.length;
  const cy = polyPoints.reduce((a,b)=>a+b.y,0)/polyPoints.length;
  const x = CANVAS_W/2, y = CANVAS_H/2;
  const mapped = polyPoints.map(p => ({x:p.x-cx,y:p.y-cy}));
  const body = createBody('custompoly', x, y, mapped.map(p=>({x:p.x,y:p.y})));
  if (body) Composite.add(world, body);
  closePolyModal();
};
document.getElementById('poly-cancel').onclick = closePolyModal;
document.getElementById('poly-reset').onclick = function(){
  polyPoints = [];
  polyFinished = false;
  drawPolyCanvas();
};
document.addEventListener('keydown', function(e){
  if (polyModalBg.style.display === 'flex' && e.key === "Escape") {
    closePolyModal();
  }
});
</script>
</body>
</html>
