<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>Matter.js 多物体演示与自定义多边形</title>
  <style>
    html, body {
      background: #eef;
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      min-height: 100vh;
      min-width: 100vw;
      user-select: none;
      overflow: hidden;
    }
    #appcontainer {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }
    #topbar {
      width: 880px;
      margin: 24px auto 4px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-family: 'Segoe UI', 'Arial', sans-serif;
    }
    #fps {
      font-size: 15px;
      color: #444;
      background: #fff7;
      padding: 3px 11px 3px 16px;
      border-radius: 4px;
      font-family: monospace;
      letter-spacing: 1px;
      min-width: 68px;
    }
    #toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    #toolbar button, #toolbar input[type=button] {
      padding: 7px 15px;
      border: none;
      border-radius: 4px;
      background: #dde3ef;
      color: #222;
      font-size: 15px;
      cursor: pointer;
      outline: none;
      transition: background 0.15s;
    }
    #toolbar button.active {
      background: #3b8eea;
      color: #fff;
    }
    #toolbar input[type=button] {
      background: #e65d5d;
      color: #fff;
      font-weight: bold;
      margin-left: 10px;
    }
    #canvas-wrap {
      position: relative;
      margin: auto;
      display: flex;
      justify-content: center;
      align-items: center;
      min-width: 420px;
      min-height: 320px;
      background: #dde6ee;
      border-radius: 8px;
      box-shadow: 0 2px 24px #bbb6;
    }
    #scene {
      background: #eef;
      display: block;
      border-radius: 5px;
      box-shadow: 0 0 4px #aaa4;
      border: 1.5px solid #8eb6e6;
      transition: box-shadow 0.15s, border 0.15s;
      outline: none;
      cursor: crosshair;
    }
    #resize-handle {
      position: absolute;
      right: 0; bottom: 0;
      width: 18px; height: 18px;
      background: linear-gradient(135deg, #8eb6e6 70%, #fff3 100%);
      border-bottom-right-radius: 7px;
      cursor: nwse-resize;
      z-index: 10;
      box-shadow: 1px 1px 4px #ccc8;
    }
    #poly-modal-bg {
      position: fixed;
      left:0;top:0;width:100vw;height:100vh;
      background: #0006;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 99;
    }
    #poly-modal {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 16px #0005;
      padding: 18px 24px 12px 24px;
      min-width: 320px;
      min-height: 320px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #poly-title {
      font-size: 18px;
      font-weight: bold;
      color: #357;
      margin-bottom: 10px;
    }
    #poly-canvas {
      border: 1.5px solid #8eb6e6;
      background: #f5f8fd;
      border-radius: 6px;
      margin-bottom: 13px;
      display: block;
      cursor: crosshair;
      box-shadow: 0 0 8px #bbb3;
    }
    #poly-btns {
      display: flex;
      gap: 10px;
      margin-top: 8px;
    }
    #poly-btns button {
      background: #3b8eea;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 7px 16px;
      font-size: 15px;
      cursor: pointer;
      transition: background 0.15s;
    }
    #poly-btns button.secondary {
      background: #dde3ef;
      color: #223;
    }
    #poly-btns button:disabled {
      background: #bfcfdf;
      color: #888;
      cursor: not-allowed;
    }
    #poly-tip {
      font-size: 13px;
      color: #4a6;
      margin-bottom: 7px;
      margin-top: -4px;
    }
    @media (max-width: 900px) {
      #topbar, #canvas-wrap { width: 98vw; }
    }
  </style>
</head>
<body>
<div id="appcontainer">
  <div id="topbar">
    <span id="fps">FPS: --</span>
    <div id="toolbar">
      <button data-shape="rectangle" class="active">矩形</button>
      <button data-shape="circle">圆形</button>
      <button data-shape="polygon3">三角形</button>
      <button data-shape="polygon4">正方形</button>
      <button data-shape="polygon5">五边形</button>
      <button data-shape="polygon6">六边形</button>
      <button data-shape="trapezoid">梯形</button>
      <button data-shape="star">星形</button>
      <button data-shape="compound">复合</button>
      <button id="poly-btn" data-shape="custompoly">自定义多边形</button>
      <input type="button" id="clear-btn" value="一键清空">
    </div>
  </div>
  <div id="canvas-wrap" style="width:840px;height:600px;">
    <canvas id="scene" width="820" height="580" tabindex="0"></canvas>
    <div id="resize-handle" title="拖动调整画布大小"></div>
  </div>
</div>
<!-- 多边形绘制弹窗 -->
<div id="poly-modal-bg">
  <div id="poly-modal">
    <div id="poly-title">自定义多边形绘制</div>
    <canvas id="poly-canvas" width="300" height="300"></canvas>
    <div id="poly-tip">左键添加点，右键撤销，双击闭合。点按“完成”可生成刚体。</div>
    <div id="poly-btns">
      <button id="poly-finish">完成</button>
      <button id="poly-cancel" class="secondary">取消</button>
      <button id="poly-reset" class="secondary">重置</button>
    </div>
  </div>
</div>
<script src="matter.min.js"></script>
<script>
const { Engine, Render, Runner, Composite, Bodies, Body, Vertices, Mouse, MouseConstraint, Events } = Matter;

const canvas = document.getElementById('scene');
const wrap = document.getElementById('canvas-wrap');
const resizeHandle = document.getElementById('resize-handle');
let CANVAS_W = canvas.width, CANVAS_H = canvas.height;

const engine = Engine.create();
const world = engine.world;
const render = Render.create({
  canvas: canvas,
  engine: engine,
  options: {
    width: CANVAS_W,
    height: CANVAS_H,
    wireframes: false,
    background: "#eef",
    hasBounds: false,
    pixelRatio: window.devicePixelRatio
  }
});
Render.run(render);
const runner = Runner.create();
Runner.run(runner, engine);

// FPS统计
let fps = 0, frameCount = 0, lastFpsUpdate = Date.now();
function updateFps() {
  frameCount++;
  const now = Date.now();
  if (now - lastFpsUpdate >= 500) {
    fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
    document.getElementById('fps').textContent = `FPS: ${fps}`;
    lastFpsUpdate = now;
    frameCount = 0;
  }
}
(function fpsLoop(){
  updateFps();
  requestAnimationFrame(fpsLoop);
})();

// 墙体
const thickness = 40;
function createWalls(w, h) {
  let arr = [
    Bodies.rectangle(w/2, h-thickness/2, w, thickness, { isStatic: true, render: { fillStyle: "#aee" } }),
    Bodies.rectangle(w/2, thickness/2, w, thickness, { isStatic: true, render: { fillStyle: "#aee" } }),
    Bodies.rectangle(thickness/2, h/2, thickness, h, { isStatic: true, render: { fillStyle: "#aee" } }),
    Bodies.rectangle(w-thickness/2, h/2, thickness, h, { isStatic: true, render: { fillStyle: "#aee" } })
  ];
  arr.forEach(b => b.label = "wall");
  return arr;
}
let walls = createWalls(CANVAS_W, CANVAS_H);
Composite.add(world, walls);

// 工具栏逻辑
const toolbar = document.getElementById('toolbar');
let currentShape = "rectangle";
toolbar.addEventListener('click', e => {
  if (e.target.tagName === "BUTTON") {
    toolbar.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
    e.target.classList.add('active');
    currentShape = e.target.getAttribute('data-shape');
    if (currentShape === 'custompoly') showPolyModal();
  }
});
document.getElementById('clear-btn').onclick = () => {
  // 只删除所有非墙体和非鼠标约束
  Composite.allBodies(world)
    .filter(b => b.label !== "wall" && b.label !== 'Mouse Constraint')
    .forEach(b => Composite.remove(world, b));
};
function resetToolbarBtn() {
  toolbar.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
  toolbar.querySelector('button[data-shape="'+currentShape+'"]')?.classList.add('active');
}

// 物体生成
function createBody(shape, x, y, customPolyVerts) {
  switch(shape) {
    case "rectangle":
      return Bodies.rectangle(x, y, 80, 40, { restitution: 0.4, friction: 0.2 });
    case "circle":
      return Bodies.circle(x, y, 32, { restitution: 0.82, friction: 0.09 });
    case "polygon3":
      return Bodies.polygon(x, y, 3, 38, { restitution: 0.6, friction: 0.2 });
    case "polygon4":
      return Bodies.polygon(x, y, 4, 36, { restitution: 0.5, friction: 0.2 });
    case "polygon5":
      return Bodies.polygon(x, y, 5, 32, { restitution: 0.5, friction: 0.2 });
    case "polygon6":
      return Bodies.polygon(x, y, 6, 30, { restitution: 0.5, friction: 0.2 });
    case "trapezoid":
      return Bodies.trapezoid(x, y, 92, 50, 0.6, { restitution: 0.45, friction: 0.16 });
    case "star": {
      // 五角星
      const pts = [];
      const R1 = 40, R2 = 16;
      for (let i = 0; i < 10; ++i) {
        const ang = Math.PI/2 + i * Math.PI/5;
        const r = i % 2 === 0 ? R1 : R2;
        pts.push({ x: x + r * Math.cos(ang), y: y - r * Math.sin(ang) });
      }
      return Bodies.fromVertices(x, y, pts, { restitution: 0.6, friction: 0.2 });
    }
    case "compound": {
      // 复合刚体
      const main = Bodies.circle(x, y, 32, { render: { fillStyle: '#fea' } });
      const left = Bodies.circle(x-22, y+28, 12, { render: { fillStyle: '#aef' } });
      const right = Bodies.circle(x+22, y+28, 12, { render: { fillStyle: '#faf' } });
      return Body.create({
        parts: [main, left, right],
        restitution: 0.7,
        friction: 0.15
      });
    }
    case "custompoly":
      if (!customPolyVerts) return null;
      // Matter.js需要点集是相对于中心
      const cx = customPolyVerts.reduce((a,b)=>a+b.x,0)/customPolyVerts.length;
      const cy = customPolyVerts.reduce((a,b)=>a+b.y,0)/customPolyVerts.length;
      const relVerts = customPolyVerts.map(p => ({ x: p.x-cx, y: p.y-cy }));
      return Bodies.fromVertices(x, y, [relVerts], { restitution: 0.55, friction: 0.18 });
    default:
      return Bodies.rectangle(x, y, 80, 40);
  }
}

// 鼠标交互
let isDragging = false, dragBody = null, dragOffset = { x:0, y:0 };
let hoveredBody = null;

canvas.addEventListener('mousedown', function(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  if (e.button === 0) { // 左键生成
    if (currentShape === 'custompoly') return; // 多边形在弹窗绘制
    // 检查是否点击在已有刚体上（避免叠加）
    const found = Matter.Query.point(Composite.allBodies(world), {x, y})
      .find(b => b.label !== "wall" && b.label !== "Mouse Constraint");
    if (found) return;
    const body = createBody(currentShape, x, y);
    if (body) Composite.add(world, body);
  } else if (e.button === 2) { // 右键拖拽
    const found = Matter.Query.point(Composite.allBodies(world), {x, y})
      .find(b => b.label !== "wall" && b.label !== "Mouse Constraint");
    if (found) {
      isDragging = true;
      dragBody = found;
      dragOffset = { x: x - found.position.x, y: y - found.position.y };
      Body.setStatic(dragBody, true);
    }
    e.preventDefault();
  } else if (e.button === 1) { // 中键删除
    const found = Matter.Query.point(Composite.allBodies(world), {x, y})
      .find(b => b.label !== "wall" && b.label !== "Mouse Constraint");
    if (found) {
      Composite.remove(world, found);
    }
    e.preventDefault();
  }
});
canvas.addEventListener('mousemove', function(e) {
  if (!isDragging) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  if (dragBody) {
    Body.setPosition(dragBody, { x: x - dragOffset.x, y: y - dragOffset.y });
    Body.setVelocity(dragBody, { x: 0, y: 0 });
    Body.setAngularVelocity(dragBody, 0);
  }
});
canvas.addEventListener('mouseup', function() {
  if (isDragging && dragBody) {
    Body.setStatic(dragBody, false);
    dragBody = null;
    isDragging = false;
  }
});
canvas.addEventListener('mouseleave', function() {
  if (isDragging && dragBody) {
    Body.setStatic(dragBody, false);
    dragBody = null;
    isDragging = false;
  }
});
canvas.addEventListener('contextmenu', e => e.preventDefault()); // 禁用右键菜单

// 鼠标拖拽约束（仅用于高亮）
const mouse = Mouse.create(canvas);
const mouseConstraint = MouseConstraint.create(engine, {
  mouse: mouse,
  constraint: { stiffness: 0.2, render: {visible: false} }
});
Composite.add(world, mouseConstraint);
render.mouse = mouse;

// 实时高亮鼠标悬停物体
Events.on(render, 'afterRender', function() {
  const mousePos = mouse.position;
  const found = Matter.Query.point(Composite.allBodies(world), mousePos)
    .find(b => b.label !== "wall" && b.label !== "Mouse Constraint");
  if (found) {
    ctx.save();
    ctx.strokeStyle = "#3b8eea";
    ctx.lineWidth = 3;
    if (found.circleRadius) {
      ctx.beginPath();
      ctx.arc(found.position.x, found.position.y, found.circleRadius+2, 0, 2*Math.PI);
      ctx.stroke();
    } else if (found.vertices) {
      ctx.beginPath();
      ctx.moveTo(found.vertices[0].x, found.vertices[0].y);
      for (let v of found.vertices) ctx.lineTo(v.x, v.y);
      ctx.closePath();
      ctx.stroke();
    }
    ctx.restore();
  }
});

// --------------------- 画布拖拽缩放 -----------------
let resizing = false, resizeStart = null, origRect = null;
resizeHandle.addEventListener('mousedown', function(e){
  resizing = true;
  resizeStart = { x: e.clientX, y: e.clientY };
  origRect = { w: wrap.offsetWidth, h: wrap.offsetHeight };
  document.body.style.cursor = 'nwse-resize';
  e.preventDefault();
});
document.addEventListener('mousemove', function(e){
  if (!resizing) return;
  const dx = e.clientX - resizeStart.x;
  const dy = e.clientY - resizeStart.y;
  let newW = Math.max(420, origRect.w + dx);
  let newH = Math.max(320, origRect.h + dy);
  wrap.style.width = newW + 'px';
  wrap.style.height = newH + 'px';
  // canvas自适应
  canvas.width = newW-20;
  canvas.height = newH-20;
  CANVAS_W = canvas.width; CANVAS_H = canvas.height;
  render.options.width = CANVAS_W;
  render.options.height = CANVAS_H;
  Render.setPixelRatio(render, window.devicePixelRatio);

  // 重新创建墙
  Composite.remove(world, walls);
  walls = createWalls(CANVAS_W, CANVAS_H);
  Composite.add(world, walls);
});
document.addEventListener('mouseup', function(e){
  if (resizing) {
    resizing = false;
    document.body.style.cursor = '';
  }
});

// --------------------- 自定义多边形弹窗 ------------------
const polyModalBg = document.getElementById('poly-modal-bg');
const polyModal = document.getElementById('poly-modal');
const polyCanvas = document.getElementById('poly-canvas');
const polyCtx = polyCanvas.getContext('2d');
let polyPoints = [];
let polyFinished = false;
function showPolyModal() {
  polyPoints = [];
  polyFinished = false;
  polyModalBg.style.display = 'flex';
  drawPolyCanvas();
}
function closePolyModal() {
  polyModalBg.style.display = 'none';
  resetToolbarBtn();
  currentShape = 'rectangle';
}
function drawPolyCanvas() {
  polyCtx.clearRect(0, 0, polyCanvas.width, polyCanvas.height);
  // 辅助线
  polyCtx.save();
  polyCtx.strokeStyle = '#eef';
  polyCtx.lineWidth = 1.5;
  for(let i=1;i<polyCanvas.width;i+=40){
    polyCtx.beginPath();
    polyCtx.moveTo(i,0); polyCtx.lineTo(i,polyCanvas.height); polyCtx.stroke();
    polyCtx.beginPath();
    polyCtx.moveTo(0,i); polyCtx.lineTo(polyCanvas.width,i); polyCtx.stroke();
  }
  polyCtx.restore();

  // 画多边形
  if (polyPoints.length) {
    polyCtx.save();
    polyCtx.beginPath();
    polyCtx.moveTo(polyPoints[0].x, polyPoints[0].y);
    for(let i=1;i<polyPoints.length;i++)
      polyCtx.lineTo(polyPoints[i].x, polyPoints[i].y);
    if (polyFinished && polyPoints.length>2) polyCtx.closePath();
    polyCtx.strokeStyle = '#3b8eea';
    polyCtx.lineWidth = 2.2;
    polyCtx.stroke();
    polyCtx.restore();

    // 画点
    polyCtx.save();
    polyPoints.forEach((p,i) => {
      polyCtx.beginPath();
      polyCtx.arc(p.x, p.y, 5, 0, 2*Math.PI);
      polyCtx.fillStyle = i==0 ? '#e63' : '#2d7';
      polyCtx.fill();
      polyCtx.strokeStyle = '#fff';
      polyCtx.lineWidth = 1.5;
      polyCtx.stroke();
    });
    polyCtx.restore();
  }
}

polyCanvas.addEventListener('mousedown', function(e) {
  if (polyFinished) return;
  const rect = polyCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  if (e.button === 0) { // 左键增加点
    polyPoints.push({x,y});
    drawPolyCanvas();
  } else if (e.button === 2) { // 右键撤销最后一个点
    polyPoints.pop();
    drawPolyCanvas();
    e.preventDefault();
  }
});
polyCanvas.addEventListener('dblclick', function(e) {
  if (polyPoints.length<3) return;
  polyFinished = true;
  drawPolyCanvas();
});
polyCanvas.addEventListener('contextmenu', e => e.preventDefault());

document.getElementById('poly-finish').onclick = function(){
  if (polyPoints.length<3) {
    alert('需要至少3个点才能生成多边形');
    return;
  }
  // 计算中心点映射到主画布中心
  const cx = polyPoints.reduce((a,b)=>a+b.x,0)/polyPoints.length;
  const cy = polyPoints.reduce((a,b)=>a+b.y,0)/polyPoints.length;
  // 映射到大画布中央
  const sceneRect = canvas.getBoundingClientRect();
  const wrapRect = wrap.getBoundingClientRect();
  // 使多边形出现在画布中央
  const x = CANVAS_W/2;
  const y = CANVAS_H/2;
  const mapped = polyPoints.map(p => ({x:p.x-cx,y:p.y-cy}));
  // 创建刚体
  const body = createBody('custompoly', x, y, mapped.map(p=>({x:p.x,y:p.y})));
  if (body) Composite.add(world, body);
  closePolyModal();
};
document.getElementById('poly-cancel').onclick = closePolyModal;
document.getElementById('poly-reset').onclick = function(){
  polyPoints = [];
  polyFinished = false;
  drawPolyCanvas();
};

// ESC关闭多边形弹窗
document.addEventListener('keydown', function(e){
  if (polyModalBg.style.display === 'flex' && e.key === "Escape") {
    closePolyModal();
  }
});
</script>
</body>
</html>