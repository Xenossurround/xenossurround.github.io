<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>2DEngine</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <style>
    html, body {
      background: #eef;
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      min-height: 100vh;
      min-width: 100vw;
      user-select: none;
      overflow: hidden;
      font-family: 'Segoe UI', 'Arial', 'PingFang SC', 'Hiragino Sans', sans-serif;
    }
    #appcontainer {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      touch-action: none;
    }
    #topbar {
      width: 98vw;
      max-width: 980px;
      margin: 22px auto 6px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      font-family: inherit;
      flex-wrap: wrap;
    }
    #fps {
      font-size: 16px;
      color: #444;
      background: #fff7;
      padding: 4px 13px 4px 17px;
      border-radius: 4px;
      font-family: monospace;
      letter-spacing: 1px;
      min-width: 72px;
      margin-right: 6px;
    }
    #toolbar {
      display: flex;
      gap: 7px;
      flex-wrap: wrap;
      align-items: center;
    }
    #toolbar button,
    #toolbar input[type=button] {
      min-width: 52px;
      padding: 9px 15px;
      border: none;
      border-radius: 6px;
      background: #dde3ef;
      color: #222;
      font-size: 17px;
      cursor: pointer;
      outline: none;
      transition: background 0.13s, color 0.13s, transform 0.08s;
      margin-bottom: 4px;
      box-shadow: 0 1px 4px #dde6ee80;
      touch-action: manipulation;
      user-select: none;
    }
    #toolbar button.active,
    #toolbar button:active,
    #toolbar input[type=button]:active {
      background: #3885e8;
      color: #fff;
      transform: scale(0.96);
      box-shadow: 0 2px 8px #7cbaff50;
    }
    #toolbar input[type=button] {
      background: #e65d5d;
      color: #fff;
      font-weight: bold;
      margin-left: 10px;
    }
    #canvas-wrap {
      position: relative;
      margin: auto;
      display: flex;
      justify-content: center;
      align-items: center;
      min-width: 90vw;
      min-height: 300px;
      background: #dde6ee;
      border-radius: 8px;
      box-shadow: 0 2px 18px #bbb7;
      width: 92vw;
      max-width: 980px;
      height: 60vw;
      max-height: 630px;
      touch-action: none;
    }
    #scene {
      background: #eef;
      display: block;
      border-radius: 5px;
      box-shadow: 0 0 4px #aaa4;
      border: 1.5px solid #8eb6e6;
      transition: box-shadow 0.13s, border 0.13s;
      outline: none;
      cursor: crosshair;
      touch-action: none;
      width: 100%;
      height: 100%;
      max-width: 950px;
      max-height: 600px;
      /* 覆盖物理像素，防止拉伸变形 */
    }
    #resize-handle {
      position: absolute;
      right: 0; bottom: 0;
      width: 26px; height: 26px;
      background: linear-gradient(135deg, #8eb6e6 75%, #fff6 100%);
      border-bottom-right-radius: 7px;
      cursor: nwse-resize;
      z-index: 10;
      box-shadow: 1px 1px 8px #ccc8;
      touch-action: none;
      display: flex;
      align-items: flex-end;
      justify-content: flex-end;
      font-size: 24px;
      color: #69a;
      user-select: none;
    }
    #resize-handle::after {
      content: "↘";
      font-size: 20px;
      color: #69a;
      opacity: 0.7;
      margin: 0 2px 2px 0;
      pointer-events: none;
      user-select: none;
    }
    #poly-modal-bg {
      position: fixed;
      left:0;top:0;width:100vw;height:100vh;
      background: #0006;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 99;
      touch-action: none;
    }
    #poly-modal {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 18px #0005;
      padding: 18px 24px 12px 24px;
      min-width: 240px;
      min-height: 220px;
      display: flex;
      flex-direction: column;
      align-items: center;
      touch-action: none;
      max-width: 95vw;
      max-height: 95vh;
    }
    #poly-title {
      font-size: 18px;
      font-weight: bold;
      color: #357;
      margin-bottom: 10px;
      margin-top: 6px;
    }
    #poly-canvas {
      border: 1.5px solid #8eb6e6;
      background: #f5f8fd;
      border-radius: 6px;
      margin-bottom: 13px;
      display: block;
      cursor: crosshair;
      box-shadow: 0 0 8px #bbb3;
      touch-action: none;
      width: 260px; height: 260px;
      max-width: 78vw;
      max-height: 60vw;
    }
    #poly-btns {
      display: flex;
      gap: 10px;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    #poly-btns button {
      background: #3b8eea;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 7px 16px;
      font-size: 15px;
      cursor: pointer;
      transition: background 0.13s;
      margin-bottom: 3px;
      min-width: 66px;
      touch-action: manipulation;
    }
    #poly-btns button.secondary {
      background: #dde3ef;
      color: #223;
    }
    #poly-btns button:disabled {
      background: #bfcfdf;
      color: #888;
      cursor: not-allowed;
    }
    #poly-tip {
      font-size: 14px;
      color: #36a85a;
      margin-bottom: 7px;
      margin-top: -4px;
      text-align: center;
      max-width: 220px;
    }
    @media (max-width: 650px) {
      #topbar { max-width: 99vw; width: 99vw; font-size: 15px;}
      #toolbar button, #toolbar input[type=button] { font-size: 16px; min-width: 44px; padding: 8px 10px; }
      #canvas-wrap { width: 99vw; min-width: 98vw; max-width: 99vw; }
      #scene { max-width: 99vw; }
      #poly-canvas { width: 90vw; height: 55vw; max-width: 90vw; }
    }
    @media (max-width: 480px) {
      #topbar { font-size: 14px;}
      #toolbar button, #toolbar input[type=button] { font-size: 15px; min-width: 38px; padding: 7px 6px;}
      #scene { max-width: 97vw;}
      #canvas-wrap { width: 99vw; min-width: 98vw; }
      #poly-canvas { width: 97vw; height: 48vw; }
    }
  </style>
</head>
<body>
<div id="appcontainer">
  <div id="topbar">
    <span id="fps">FPS: --</span>
    <div id="toolbar">
      <button data-shape="rectangle" class="active">矩形</button>
      <button data-shape="circle">圆形</button>
      <button data-shape="polygon3">三角形</button>
      <button data-shape="polygon4">正方形</button>
      <button data-shape="polygon5">五边形</button>
      <button data-shape="polygon6">六边形</button>
      <button data-shape="trapezoid">梯形</button>
      <button data-shape="star">星形</button>
      <button data-shape="compound">复合</button>
      <button id="poly-btn" data-shape="custompoly">自定义多边形</button>
      <input type="button" id="clear-btn" value="一键清空">
    </div>
  </div>
  <div id="canvas-wrap">
    <canvas id="scene" width="780" height="540" tabindex="0"></canvas>
    <div id="resize-handle"></div>
  </div>
</div>
<div id="poly-modal-bg">
  <div id="poly-modal">
    <div id="poly-title">自定义多边形绘制</div>
    <canvas id="poly-canvas" width="260" height="260"></canvas>
    <div id="poly-tip">轻触添加点，双击/双指点按闭合，双指长按撤销，完成后点“完成”</div>
    <div id="poly-btns">
      <button id="poly-finish">完成</button>
      <button id="poly-cancel" class="secondary">取消</button>
      <button id="poly-reset" class="secondary">重置</button>
    </div>
  </div>
</div>
<script src="matter.js"></script>
<script>
const { Engine, Render, Runner, Composite, Bodies, Body, Vertices, Mouse, MouseConstraint, Events, Query } = Matter;

const canvas = document.getElementById('scene');
const wrap = document.getElementById('canvas-wrap');
const resizeHandle = document.getElementById('resize-handle');
let CANVAS_W = canvas.width, CANVAS_H = canvas.height;
let isMobile = /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent);

function setCanvasSize(w, h) {
  canvas.width = w;
  canvas.height = h;
  wrap.style.width = w + 'px';
  wrap.style.height = h + 'px';
  CANVAS_W = w;
  CANVAS_H = h;
  render.options.width = w;
  render.options.height = h;
  Render.setPixelRatio(render, window.devicePixelRatio);
}
if (isMobile) {
  // 初始更适配
  setCanvasSize(Math.min(window.innerWidth*0.99, 430), Math.min(window.innerHeight*0.6, 420));
} else {
  setCanvasSize(780, 540);
}

const engine = Engine.create();
const world = engine.world;
const render = Render.create({
  canvas: canvas,
  engine: engine,
  options: {
    width: CANVAS_W,
    height: CANVAS_H,
    wireframes: false,
    background: "#eef",
    hasBounds: false,
    pixelRatio: window.devicePixelRatio
  }
});
Render.run(render);
const runner = Runner.create();
Runner.run(runner, engine);

// FPS统计
let fps = 0, frameCount = 0, lastFpsUpdate = Date.now();
function updateFps() {
  frameCount++;
  const now = Date.now();
  if (now - lastFpsUpdate >= 500) {
    fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
    document.getElementById('fps').textContent = `FPS: ${fps}`;
    lastFpsUpdate = now;
    frameCount = 0;
  }
}
(function fpsLoop(){
  updateFps();
  requestAnimationFrame(fpsLoop);
})();

const thickness = 40;
function createWalls(w, h) {
  let arr = [
    Bodies.rectangle(w/2, h-thickness/2, w, thickness, { isStatic: true, render: { fillStyle: "#aee" } }),
    Bodies.rectangle(w/2, thickness/2, w, thickness, { isStatic: true, render: { fillStyle: "#aee" } }),
    Bodies.rectangle(thickness/2, h/2, thickness, h, { isStatic: true, render: { fillStyle: "#aee" } }),
    Bodies.rectangle(w-thickness/2, h/2, thickness, h, { isStatic: true, render: { fillStyle: "#aee" } })
  ];
  arr.forEach(b => b.label = "wall");
  return arr;
}
let walls = createWalls(CANVAS_W, CANVAS_H);
Composite.add(world, walls);

// 工具栏逻辑
const toolbar = document.getElementById('toolbar');
let currentShape = "rectangle";
toolbar.addEventListener('click', e => {
  if (e.target.tagName === "BUTTON") {
    toolbar.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
    e.target.classList.add('active');
    currentShape = e.target.getAttribute('data-shape');
    if (currentShape === 'custompoly') showPolyModal();
  }
});
document.getElementById('clear-btn').onclick = () => {
  // 只删除所有非墙体和非鼠标约束
  Composite.allBodies(world)
    .filter(b => b.label !== "wall" && b.label !== 'Mouse Constraint')
    .forEach(b => Composite.remove(world, b));
};
function resetToolbarBtn() {
  toolbar.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
  toolbar.querySelector('button[data-shape="'+currentShape+'"]')?.classList.add('active');
}

// 物体生成
function createBody(shape, x, y, customPolyVerts) {
  switch(shape) {
    case "rectangle":
      return Bodies.rectangle(x, y, 80, 40, { restitution: 0.4, friction: 0.2 });
    case "circle":
      return Bodies.circle(x, y, 32, { restitution: 0.82, friction: 0.09 });
    case "polygon3":
      return Bodies.polygon(x, y, 3, 38, { restitution: 0.6, friction: 0.2 });
    case "polygon4":
      return Bodies.polygon(x, y, 4, 36, { restitution: 0.5, friction: 0.2 });
    case "polygon5":
      return Bodies.polygon(x, y, 5, 32, { restitution: 0.5, friction: 0.2 });
    case "polygon6":
      return Bodies.polygon(x, y, 6, 30, { restitution: 0.5, friction: 0.2 });
    case "trapezoid":
      return Bodies.trapezoid(x, y, 92, 50, 0.6, { restitution: 0.45, friction: 0.16 });
    case "star": {
      // 五角星
      const pts = [];
      const R1 = 40, R2 = 16;
      for (let i = 0; i < 10; ++i) {
        const ang = Math.PI/2 + i * Math.PI/5;
        const r = i % 2 === 0 ? R1 : R2;
        pts.push({ x: x + r * Math.cos(ang), y: y - r * Math.sin(ang) });
      }
      return Bodies.fromVertices(x, y, pts, { restitution: 0.6, friction: 0.2 });
    }
    case "compound": {
      const main = Bodies.circle(x, y, 32, { render: { fillStyle: '#fea' } });
      const left = Bodies.circle(x-22, y+28, 12, { render: { fillStyle: '#aef' } });
      const right = Bodies.circle(x+22, y+28, 12, { render: { fillStyle: '#faf' } });
      return Body.create({
        parts: [main, left, right],
        restitution: 0.7,
        friction: 0.15
      });
    }
    case "custompoly":
      if (!customPolyVerts) return null;
      const cx = customPolyVerts.reduce((a,b)=>a+b.x,0)/customPolyVerts.length;
      const cy = customPolyVerts.reduce((a,b)=>a+b.y,0)/customPolyVerts.length;
      const relVerts = customPolyVerts.map(p => ({ x: p.x-cx, y: p.y-cy }));
      return Bodies.fromVertices(x, y, [relVerts], { restitution: 0.55, friction: 0.18 });
    default:
      return Bodies.rectangle(x, y, 80, 40);
  }
}

// 鼠标/触控交互
let isDragging = false, dragBody = null, dragOffset = { x:0, y:0 };
let dragPointerId = null;
let touchLongPressTimer = null, touchStartTime = 0, touchMoved = false, touchStart = null;

function pointerPos(e) {
  if (e.touches && e.touches.length>0)
    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  else if (e.changedTouches && e.changedTouches.length>0)
    return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
  else
    return { x: e.clientX, y: e.clientY };
}
function getBodyAt(x, y) {
  return Query.point(Composite.allBodies(world), {x, y})
    .find(b => b.label !== "wall" && b.label !== "Mouse Constraint");
}

// 桌面端
canvas.addEventListener('mousedown', function(e) {
  if (e.button === 0 && !isMobile) { // 左键生成
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    if (currentShape === 'custompoly') return;
    // 检查是否有物体
    if (getBodyAt(x, y)) return;
    const body = createBody(currentShape, x, y);
    if (body) Composite.add(world, body);
  } else if (e.button === 2 && !isMobile) { // 右键拖拽
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const found = getBodyAt(x, y);
    if (found) {
      isDragging = true;
      dragBody = found;
      dragOffset = { x: x - found.position.x, y: y - found.position.y };
      Body.setStatic(dragBody, true);
    }
    e.preventDefault();
  } else if (e.button === 1 && !isMobile) { // 中键删除
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const found = getBodyAt(x, y);
    if (found) Composite.remove(world, found);
    e.preventDefault();
  }
});
canvas.addEventListener('mousemove', function(e) {
  if (!isDragging) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  if (dragBody) {
    Body.setPosition(dragBody, { x: x - dragOffset.x, y: y - dragOffset.y });
    Body.setVelocity(dragBody, { x: 0, y: 0 });
    Body.setAngularVelocity(dragBody, 0);
  }
});
canvas.addEventListener('mouseup', function() {
  if (isDragging && dragBody) {
    Body.setStatic(dragBody, false);
    dragBody = null;
    isDragging = false;
  }
});
canvas.addEventListener('mouseleave', function() {
  if (isDragging && dragBody) {
    Body.setStatic(dragBody, false);
    dragBody = null;
    isDragging = false;
  }
});
canvas.addEventListener('contextmenu', e => e.preventDefault());

// 手机端触控
canvas.addEventListener('touchstart', function(e) {
  if (!isMobile) return;
  // 单指：生成或拖拽。长按删除
  if (e.touches.length === 1) {
    const rect = canvas.getBoundingClientRect();
    const x = e.touches[0].clientX - rect.left;
    const y = e.touches[0].clientY - rect.top;
    const found = getBodyAt(x, y);
    touchMoved = false;
    touchStart = {x, y};
    // 长按删除
    touchLongPressTimer = setTimeout(function(){
      if (getBodyAt(x, y)) {
        Composite.remove(world, getBodyAt(x, y));
      }
    }, 520); // 0.5秒长按
    touchStartTime = Date.now();
    if (found) {
      isDragging = true;
      dragBody = found;
      dragOffset = { x: x - found.position.x, y: y - found.position.y };
      dragPointerId = e.touches[0].identifier;
      Body.setStatic(dragBody, true);
    } else {
      // 新建
      if (currentShape !== 'custompoly') {
        const body = createBody(currentShape, x, y);
        if (body) Composite.add(world, body);
      }
    }
  }
}, {passive:false});
canvas.addEventListener('touchmove', function(e) {
  if (!isMobile) return;
  touchMoved = true;
  clearTimeout(touchLongPressTimer);
  if (!isDragging) return;
  const rect = canvas.getBoundingClientRect();
  let idx = 0;
  for (let i=0;i<e.touches.length;i++) {
    if (e.touches[i].identifier === dragPointerId) { idx = i; break;}
  }
  const x = e.touches[idx].clientX - rect.left;
  const y = e.touches[idx].clientY - rect.top;
  if (dragBody) {
    Body.setPosition(dragBody, { x: x - dragOffset.x, y: y - dragOffset.y });
    Body.setVelocity(dragBody, { x: 0, y: 0 });
    Body.setAngularVelocity(dragBody, 0);
  }
});
canvas.addEventListener('touchend', function(e) {
  if (!isMobile) return;
  clearTimeout(touchLongPressTimer);
  if (isDragging && dragBody) {
    Body.setStatic(dragBody, false);
    dragBody = null;
    isDragging = false;
    dragPointerId = null;
  }
});
canvas.addEventListener('touchcancel', function(e) {
  if (!isMobile) return;
  clearTimeout(touchLongPressTimer);
  if (isDragging && dragBody) {
    Body.setStatic(dragBody, false);
    dragBody = null;
    isDragging = false;
    dragPointerId = null;
  }
});

// 鼠标拖拽约束（用于高亮）
const mouse = Mouse.create(canvas);
const mouseConstraint = MouseConstraint.create(engine, {
  mouse: mouse,
  constraint: { stiffness: 0.2, render: {visible: false} }
});
Composite.add(world, mouseConstraint);
render.mouse = mouse;

// 高亮物体
Events.on(render, 'afterRender', function() {
  const mousePos = isMobile ? touchStart || {x:-1000,y:-1000} : mouse.position;
  const found = getBodyAt(mousePos.x, mousePos.y);
  if (found) {
    ctx.save();
    ctx.strokeStyle = "#3b8eea";
    ctx.lineWidth = 3;
    if (found.circleRadius) {
      ctx.beginPath();
      ctx.arc(found.position.x, found.position.y, found.circleRadius+2, 0, 2*Math.PI);
      ctx.stroke();
    } else if (found.vertices) {
      ctx.beginPath();
      ctx.moveTo(found.vertices[0].x, found.vertices[0].y);
      for (let v of found.vertices) ctx.lineTo(v.x, v.y);
      ctx.closePath();
      ctx.stroke();
    }
    ctx.restore();
  }
});

// 画布拖拽缩放（支持触控&鼠标）
let resizing = false, resizeStart = null, origRect = null;
let resizeTouchId = null;
resizeHandle.addEventListener('mousedown', function(e){
  resizing = true;
  resizeStart = { x: e.clientX, y: e.clientY };
  origRect = { w: wrap.offsetWidth, h: wrap.offsetHeight };
  document.body.style.cursor = 'nwse-resize';
  e.preventDefault();
});
resizeHandle.addEventListener('touchstart', function(e){
  resizing = true;
  resizeTouchId = e.touches[0].identifier;
  resizeStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  origRect = { w: wrap.offsetWidth, h: wrap.offsetHeight };
  e.preventDefault();
}, {passive:false});
function doResize(x, y) {
  let dx = x - resizeStart.x;
  let dy = y - resizeStart.y;
  let newW = Math.max(280, origRect.w + dx);
  let newH = Math.max(180, origRect.h + dy);
  setCanvasSize(newW-20, newH-20);
  // 重新创建墙
  Composite.remove(world, walls);
  walls = createWalls(CANVAS_W, CANVAS_H);
  Composite.add(world, walls);
}
document.addEventListener('mousemove', function(e){
  if (!resizing) return;
  doResize(e.clientX, e.clientY);
});
document.addEventListener('touchmove', function(e){
  if (!resizing) return;
  let i = 0;
  for(;i<e.touches.length;i++) {
    if (e.touches[i].identifier === resizeTouchId) break;
  }
  if (i === e.touches.length) return;
  doResize(e.touches[i].clientX, e.touches[i].clientY);
}, {passive:false});
document.addEventListener('mouseup', function(e){
  if (resizing) {
    resizing = false;
    document.body.style.cursor = '';
  }
});
document.addEventListener('touchend', function(e){
  if (resizing) {
    resizing = false;
    document.body.style.cursor = '';
    resizeTouchId = null;
  }
}, {passive:false});

// --------------------- 自定义多边形弹窗，支持触控 ------------------
const polyModalBg = document.getElementById('poly-modal-bg');
const polyModal = document.getElementById('poly-modal');
const polyCanvas = document.getElementById('poly-canvas');
const polyCtx = polyCanvas.getContext('2d');
let polyPoints = [];
let polyFinished = false;
let polyTouchStart = null, polyTouchTimer = null, polyTouchCount = 0;

function showPolyModal() {
  polyPoints = [];
  polyFinished = false;
  polyModalBg.style.display = 'flex';
  drawPolyCanvas();
}
function closePolyModal() {
  polyModalBg.style.display = 'none';
  resetToolbarBtn();
  currentShape = 'rectangle';
}
function drawPolyCanvas() {
  polyCtx.clearRect(0, 0, polyCanvas.width, polyCanvas.height);
  // 辅助线
  polyCtx.save();
  polyCtx.strokeStyle = '#eef';
  polyCtx.lineWidth = 1.1;
  for(let i=1;i<polyCanvas.width;i+=34){
    polyCtx.beginPath();
    polyCtx.moveTo(i,0); polyCtx.lineTo(i,polyCanvas.height); polyCtx.stroke();
    polyCtx.beginPath();
    polyCtx.moveTo(0,i); polyCtx.lineTo(polyCanvas.width,i); polyCtx.stroke();
  }
  polyCtx.restore();
  if (polyPoints.length) {
    polyCtx.save();
    polyCtx.beginPath();
    polyCtx.moveTo(polyPoints[0].x, polyPoints[0].y);
    for(let i=1;i<polyPoints.length;i++)
      polyCtx.lineTo(polyPoints[i].x, polyPoints[i].y);
    if (polyFinished && polyPoints.length>2) polyCtx.closePath();
    polyCtx.strokeStyle = '#3b8eea';
    polyCtx.lineWidth = 2.1;
    polyCtx.stroke();
    polyCtx.restore();
    polyCtx.save();
    polyPoints.forEach((p,i) => {
      polyCtx.beginPath();
      polyCtx.arc(p.x, p.y, 5, 0, 2*Math.PI);
      polyCtx.fillStyle = i==0 ? '#e63' : '#2d7';
      polyCtx.fill();
      polyCtx.strokeStyle = '#fff';
      polyCtx.lineWidth = 1.1;
      polyCtx.stroke();
    });
    polyCtx.restore();
  }
}
function polyCanvasAddPoint(x, y) {
  polyPoints.push({x, y});
  drawPolyCanvas();
}
function polyCanvasUndoPoint() {
  polyPoints.pop();
  drawPolyCanvas();
}
polyCanvas.addEventListener('mousedown', function(e) {
  if (polyFinished) return;
  if (e.button === 0) {
    const rect = polyCanvas.getBoundingClientRect();
    polyCanvasAddPoint(e.clientX-rect.left, e.clientY-rect.top);
  }
});
polyCanvas.addEventListener('dblclick', function(e) {
  if (polyPoints.length<3) return;
  polyFinished = true;
  drawPolyCanvas();
});
polyCanvas.addEventListener('contextmenu', e => { polyCanvasUndoPoint(); e.preventDefault(); });

// 手机端触控
polyCanvas.addEventListener('touchstart', function(e) {
  if (polyFinished) return;
  polyTouchCount = e.touches.length;
  const rect = polyCanvas.getBoundingClientRect();
  if (e.touches.length === 1) {
    polyTouchStart = {x: e.touches[0].clientX-rect.left, y: e.touches[0].clientY-rect.top};
    polyTouchTimer = setTimeout(function(){
      // 长按无事
    }, 450);
  }
  else if (e.touches.length === 2) {
    // 双指：撤销最后一个点
    polyCanvasUndoPoint();
    e.preventDefault();
  }
});
polyCanvas.addEventListener('touchend', function(e) {
  if (polyFinished) return;
  if (polyTouchCount === 1 && e.changedTouches.length === 1) {
    // 单指轻触加点
    if (polyTouchStart) {
      polyCanvasAddPoint(polyTouchStart.x, polyTouchStart.y);
      polyTouchStart = null;
    }
  }
  if (e.touches.length === 0) {
    clearTimeout(polyTouchTimer);
    polyTouchCount = 0;
  }
});
polyCanvas.addEventListener('touchmove', function(e) {
  clearTimeout(polyTouchTimer);
});
polyCanvas.addEventListener('dblclick', function(e) {
  if (polyPoints.length<3) return;
  polyFinished = true;
  drawPolyCanvas();
});
polyCanvas.addEventListener('touchstart', function(e){
  if (!polyFinished && e.touches.length === 2) {
    // 双指点按闭合
    if (polyPoints.length >= 3) {
      polyFinished = true;
      drawPolyCanvas();
    }
    e.preventDefault();
  }
});
document.getElementById('poly-finish').onclick = function(){
  if (polyPoints.length<3) {
    alert('需要至少3个点才能生成多边形');
    return;
  }
  // 计算中心点映射到主画布中心
  const cx = polyPoints.reduce((a,b)=>a+b.x,0)/polyPoints.length;
  const cy = polyPoints.reduce((a,b)=>a+b.y,0)/polyPoints.length;
  const x = CANVAS_W/2;
  const y = CANVAS_H/2;
  const mapped = polyPoints.map(p => ({x:p.x-cx,y:p.y-cy}));
  const body = createBody('custompoly', x, y, mapped.map(p=>({x:p.x,y:p.y})));
  if (body) Composite.add(world, body);
  closePolyModal();
};
document.getElementById('poly-cancel').onclick = closePolyModal;
document.getElementById('poly-reset').onclick = function(){
  polyPoints = [];
  polyFinished = false;
  drawPolyCanvas();
};
document.addEventListener('keydown', function(e){
  if (polyModalBg.style.display === 'flex' && e.key === "Escape") {
    closePolyModal();
  }
});

window.addEventListener('resize', function(){
  // 保持画布最大宽度适配
  let w = Math.min(window.innerWidth*0.98, 940);
  let h = Math.min(window.innerHeight*0.64, 600);
  setCanvasSize(w, h);
  Composite.remove(world, walls);
  walls = createWalls(CANVAS_W, CANVAS_H);
  Composite.add(world, walls);
});
</script>
</body>
</html>
