<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>Matter.js 多物体演示（点击位置精准）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1,user-scalable=no">
  <style>
    html, body {
      background: #eef;
      margin: 0; padding: 0; width: 100vw; height: 100vh;
      user-select: none; overflow: hidden; font-family: 'Segoe UI', 'Arial', sans-serif;
    }
    #appcontainer { width: 100vw; min-height: 100vh; display: flex; flex-direction: column; align-items: center; }
    #topbar {
      width: 98vw; max-width: 900px; margin: 2vw auto 4px;
      display: flex; align-items: center; justify-content: space-between; gap: 10px; font-size: 16px; flex-wrap: wrap;
    }
    #fps { font-size: 15px; color: #444; background: #fff7; padding: 3px 11px 3px 16px; border-radius: 4px; font-family: monospace; letter-spacing: 1px; min-width: 68px; margin-bottom: 4px; }
    #toolbar { display: flex; gap: 7px; flex-wrap: wrap; align-items: center; }
    #toolbar button, #toolbar input[type=button] {
      padding: 8px 14px; border: none; border-radius: 5px; background: #dde3ef; color: #222; font-size: 16px;
      cursor: pointer; outline: none; transition: background 0.15s, transform 0.09s; min-width: 60px; margin-bottom: 4px; box-shadow: 0 1px 2px #0001;
    }
    #toolbar button.active, #toolbar button:active { background: #3b8eea; color: #fff; transform: scale(0.96);}
    #toolbar input[type=button] { background: #e65d5d; color: #fff; font-weight: bold; margin-left: 10px;}
    #canvas-wrap {
      position: relative; width: 98vw; max-width: 900px; min-width: 260px; min-height: 220px; flex: 1 1 60vh;
      display: flex; justify-content: center; align-items: center; background: #dde6ee; border-radius: 8px; box-shadow: 0 2px 24px #bbb7;
      margin: auto; margin-bottom: 2.5vh; touch-action: none; transition: box-shadow 0.13s, border 0.15s;
    }
    #scene {
      background: #eef; display: block; border-radius: 5px; box-shadow: 0 0 4px #aaa3; border: 1.5px solid #8eb6e6;
      outline: none; cursor: crosshair; width: 100%; height: 100%; max-width: 100vw; max-height: 70vh; touch-action: none;
      user-select: none; -webkit-tap-highlight-color: transparent; transition: box-shadow 0.15s, border 0.15s;
    }
    #resize-handle {
      position: absolute; right: 3px; bottom: 3px; width: 20px; height: 20px;
      background: linear-gradient(135deg, #8eb6e6 60%, #fff3 100%);
      border-bottom-right-radius: 7px; cursor: nwse-resize; z-index: 10; box-shadow: 1px 1px 4px #ccc8; touch-action: none; display: block;
    }
    #poly-modal-bg { position: fixed; left:0;top:0;width:100vw;height:100vh; background: #0006; display: none; align-items: center; justify-content: center; z-index: 99; touch-action: none;}
    #poly-modal { background: #fff; border-radius: 10px; box-shadow: 0 2px 16px #0005; padding: 14px 10px 12px 10px; min-width: 220px; min-height: 240px; display: flex; flex-direction: column; align-items: center; max-width: 95vw; max-height: 88vh;}
    #poly-title { font-size: 18px; font-weight: bold; color: #357; margin-bottom: 8px; text-align: center;}
    #poly-canvas { border: 1.5px solid #8eb6e6; background: #f5f8fd; border-radius: 6px; margin-bottom: 10px; display: block; cursor: crosshair; box-shadow: 0 0 8px #bbb3; width: 220px; height: 220px; touch-action: none; max-width: 90vw; max-height: 40vh;}
    #poly-btns { display: flex; gap: 7px; margin-top: 7px; flex-wrap: wrap;}
    #poly-btns button { background: #3b8eea; color: #fff; border: none; border-radius: 4px; padding: 7px 16px; font-size: 15px; cursor: pointer; transition: background 0.15s, transform 0.12s; margin-bottom: 4px;}
    #poly-btns button.secondary { background: #dde3ef; color: #223;}
    #poly-btns button:disabled { background: #bfcfdf; color: #888; cursor: not-allowed;}
    #poly-tip { font-size: 12px; color: #4a6; margin-bottom: 3px; margin-top: -2px; text-align: center;}
    @media (max-width: 600px) {
      #topbar, #canvas-wrap { width: 99vw; min-width: 0; max-width: 99vw; border-radius: 0; box-shadow: none;}
      #scene { border-radius: 0; } #poly-modal { min-width: 0; } #poly-canvas { width: 95vw; height: 40vw; min-width: 140px; min-height: 120px;}
    }
    @media (max-width: 430px) {
      #poly-canvas { width: 92vw; height: 38vw; }
      #topbar { font-size: 14px; }
      #toolbar button, #toolbar input[type=button] { font-size: 14px; min-width: 40px;}
    }
  </style>
</head>
<body>
<div id="appcontainer">
  <div id="topbar">
    <span id="fps">FPS: --</span>
    <div id="toolbar">
      <button data-shape="rectangle" class="active">矩形</button>
      <button data-shape="circle">圆形</button>
      <button data-shape="polygon3">三角</button>
      <button data-shape="polygon4">正方</button>
      <button data-shape="polygon5">五边</button>
      <button data-shape="polygon6">六边</button>
      <button data-shape="trapezoid">梯形</button>
      <button data-shape="star">星形</button>
      <button data-shape="compound">复合</button>
      <button id="poly-btn" data-shape="custompoly">多边形</button>
      <input type="button" id="clear-btn" value="清空">
    </div>
  </div>
  <div id="canvas-wrap" style="width:96vw;min-width:260px;min-height:220px;max-width:900px;">
    <canvas id="scene" width="790" height="530" tabindex="0"></canvas>
    <div id="resize-handle" title="拖动调整画布大小"></div>
  </div>
</div>
<div id="poly-modal-bg">
  <div id="poly-modal">
    <div id="poly-title">自定义多边形</div>
    <canvas id="poly-canvas" width="220" height="220"></canvas>
    <div id="poly-tip">
      单击加点，长按撤销，双击闭合。点“完成”生成刚体。
    </div>
    <div id="poly-btns">
      <button id="poly-finish">完成</button>
      <button id="poly-cancel" class="secondary">取消</button>
      <button id="poly-reset" class="secondary">重置</button>
    </div>
  </div>
</div>
<script src="matter.js"></script>
<script>
const { Engine, Render, Runner, Composite, Bodies, Body, Vertices, Mouse, MouseConstraint, Events, Query } = Matter;

let CANVAS_W = Math.min(window.innerWidth * 0.97, 790), CANVAS_H = Math.min(window.innerHeight * 0.68, 530);
const canvas = document.getElementById('scene');
const wrap = document.getElementById('canvas-wrap');
function setCanvasSize(w, h) {
  canvas.width = w;
  canvas.height = h;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  render.options.width = w;
  render.options.height = h;
}
setCanvasSize(CANVAS_W, CANVAS_H);
wrap.style.width = (CANVAS_W+20)+'px';
wrap.style.height = (CANVAS_H+20)+'px';

const resizeHandle = document.getElementById('resize-handle');
const engine = Engine.create();
const world = engine.world;
const render = Render.create({
  canvas: canvas,
  engine: engine,
  options: {
    width: CANVAS_W,
    height: CANVAS_H,
    wireframes: false,
    background: "#eef",
    hasBounds: false,
    pixelRatio: window.devicePixelRatio
  }
});
Render.run(render);
const runner = Runner.create();
Runner.run(runner, engine);

let walls = [];
function createWalls(w, h) {
  let arr = [
    Bodies.rectangle(w/2, h-12, w, 24, { isStatic: true, render: { fillStyle: "#aee" }, label:"wall" }),
    Bodies.rectangle(w/2, 12, w, 24, { isStatic: true, render: { fillStyle: "#aee" }, label:"wall" }),
    Bodies.rectangle(12, h/2, 24, h, { isStatic: true, render: { fillStyle: "#aee" }, label:"wall" }),
    Bodies.rectangle(w-12, h/2, 24, h, { isStatic: true, render: { fillStyle: "#aee" }, label:"wall" })
  ];
  arr.forEach(b => b.label = "wall");
  return arr;
}
function updateWalls() {
  Composite.remove(world, walls);
  walls = createWalls(canvas.width, canvas.height);
  Composite.add(world, walls);
}
walls = createWalls(canvas.width, canvas.height);
Composite.add(world, walls);

// FPS统计
let fps = 0, frameCount = 0, lastFpsUpdate = Date.now();
function updateFps() {
  frameCount++;
  const now = Date.now();
  if (now - lastFpsUpdate >= 500) {
    fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
    document.getElementById('fps').textContent = `FPS: ${fps}`;
    lastFpsUpdate = now;
    frameCount = 0;
  }
}
(function fpsLoop(){
  updateFps();
  requestAnimationFrame(fpsLoop);
})();

// UI/工具栏逻辑
const toolbar = document.getElementById('toolbar');
let currentShape = "rectangle";
toolbar.addEventListener('click', e => {
  if (e.target.tagName === "BUTTON") {
    toolbar.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
    e.target.classList.add('active');
    currentShape = e.target.getAttribute('data-shape');
    if (currentShape === 'custompoly') showPolyModal();
  }
});
document.getElementById('clear-btn').onclick = () => {
  Composite.allBodies(world)
    .filter(b => b.label !== "wall" && b.label !== 'Mouse Constraint')
    .forEach(b => Composite.remove(world, b));
};
function resetToolbarBtn() {
  toolbar.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
  toolbar.querySelector('button[data-shape="'+currentShape+'"]')?.classList.add('active');
}

// 物体生成
function createBody(shape, x, y, customPolyVerts) {
  switch(shape) {
    case "rectangle":
      return Bodies.rectangle(x, y, 68, 34, { restitution: 0.45, friction: 0.2 });
    case "circle":
      return Bodies.circle(x, y, 26, { restitution: 0.82, friction: 0.09 });
    case "polygon3":
      return Bodies.polygon(x, y, 3, 29, { restitution: 0.6, friction: 0.2 });
    case "polygon4":
      return Bodies.polygon(x, y, 4, 27, { restitution: 0.5, friction: 0.2 });
    case "polygon5":
      return Bodies.polygon(x, y, 5, 24, { restitution: 0.5, friction: 0.19 });
    case "polygon6":
      return Bodies.polygon(x, y, 6, 22, { restitution: 0.5, friction: 0.18 });
    case "trapezoid":
      return Bodies.trapezoid(x, y, 68, 34, 0.6, { restitution: 0.47, friction: 0.15 });
    case "star": {
      const pts = [];
      const R1 = 32, R2 = 12;
      for (let i = 0; i < 10; ++i) {
        const ang = Math.PI/2 + i * Math.PI/5;
        const r = i % 2 === 0 ? R1 : R2;
        pts.push({ x: x + r * Math.cos(ang), y: y - r * Math.sin(ang) });
      }
      return Bodies.fromVertices(x, y, pts, { restitution: 0.6, friction: 0.2 });
    }
    case "compound": {
      const main = Bodies.circle(x, y, 22, { render: { fillStyle: '#fea' } });
      const left = Bodies.circle(x-14, y+20, 8, { render: { fillStyle: '#aef' } });
      const right = Bodies.circle(x+14, y+20, 8, { render: { fillStyle: '#faf' } });
      return Body.create({
        parts: [main, left, right],
        restitution: 0.7,
        friction: 0.15
      });
    }
    case "custompoly":
      if (!customPolyVerts) return null;
      const cx = customPolyVerts.reduce((a,b)=>a+b.x,0)/customPolyVerts.length;
      const cy = customPolyVerts.reduce((a,b)=>a+b.y,0)/customPolyVerts.length;
      const relVerts = customPolyVerts.map(p => ({ x: p.x-cx, y: p.y-cy }));
      return Bodies.fromVertices(x, y, [relVerts], { restitution: 0.55, friction: 0.18 });
    default:
      return Bodies.rectangle(x, y, 68, 34);
  }
}

// 坐标换算，style/属性一致，不需要scale
function getCanvasPos(e, targetCanvas = canvas) {
  const rect = targetCanvas.getBoundingClientRect();
  let clientX, clientY;
  if (e.touches && e.touches.length) {
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  } else if (e.changedTouches && e.changedTouches.length) {
    clientX = e.changedTouches[0].clientX;
    clientY = e.changedTouches[0].clientY;
  } else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  return {
    x: clientX - rect.left,
    y: clientY - rect.top
  };
}

let isDragging = false, dragBody = null, dragOffset = { x:0, y:0 };
let lastTouchTime = 0, dragTouchId = null, dragStart = null;
let dragLongPressTimer = null;
let maxBodies = 80;

function getBodyAt(x, y) {
  return Matter.Query.point(Composite.allBodies(world), {x, y})
    .find(b => b.label !== "wall" && b.label !== "Mouse Constraint");
}

canvas.addEventListener('mousedown', function(e) {
  const {x, y} = getCanvasPos(e);
  if (e.button === 0) {
    if (currentShape === 'custompoly') return;
    if (Composite.allBodies(world).length > maxBodies+8) return;
    if (getBodyAt(x, y)) return;
    const body = createBody(currentShape, x, y);
    if (body) Composite.add(world, body);
  } else if (e.button === 2) {
    const found = getBodyAt(x, y);
    if (found) {
      isDragging = true;
      dragBody = found;
      dragOffset = { x: x - found.position.x, y: y - found.position.y };
      Body.setStatic(dragBody, true);
    }
    e.preventDefault();
  } else if (e.button === 1) {
    const found = getBodyAt(x, y);
    if (found) Composite.remove(world, found);
    e.preventDefault();
  }
});
canvas.addEventListener('mousemove', function(e) {
  if (!isDragging) return;
  const {x, y} = getCanvasPos(e);
  if (dragBody) {
    Body.setPosition(dragBody, { x: x - dragOffset.x, y: y - dragOffset.y });
    Body.setVelocity(dragBody, { x: 0, y: 0 });
    Body.setAngularVelocity(dragBody, 0);
  }
});
canvas.addEventListener('mouseup', function() {
  if (isDragging && dragBody) {
    Body.setStatic(dragBody, false);
    dragBody = null;
    isDragging = false;
  }
});
canvas.addEventListener('mouseleave', function() {
  if (isDragging && dragBody) {
    Body.setStatic(dragBody, false);
    dragBody = null;
    isDragging = false;
  }
});
canvas.addEventListener('contextmenu', e => e.preventDefault());

canvas.addEventListener('touchstart', function(e) {
  if (!e.targetTouches.length) return;
  const {x, y} = getCanvasPos(e);
  if (e.targetTouches.length === 2) {
    const found = getBodyAt(x, y);
    if (found) Composite.remove(world, found);
    return;
  }
  const touch = e.targetTouches[0];
  dragLongPressTimer = setTimeout(()=>{
    const found = getBodyAt(x, y);
    if (found) {
      isDragging = true;
      dragBody = found;
      dragTouchId = touch.identifier;
      dragOffset = { x: x - found.position.x, y: y - found.position.y };
      Body.setStatic(dragBody, true);
    }
  }, 420);
  dragStart = { x, y };
});

canvas.addEventListener('touchmove', function(e) {
  if (!isDragging) {
    if (dragLongPressTimer) clearTimeout(dragLongPressTimer);
    return;
  }
  for (let i=0;i<e.changedTouches.length;i++) {
    const t = e.changedTouches[i];
    if (t.identifier === dragTouchId) {
      const {x, y} = getCanvasPos(t);
      if (dragBody) {
        Body.setPosition(dragBody, { x: x - dragOffset.x, y: y - dragOffset.y });
        Body.setVelocity(dragBody, { x: 0, y: 0 });
        Body.setAngularVelocity(dragBody, 0);
      }
    }
  }
  e.preventDefault();
});

canvas.addEventListener('touchend', function(e) {
  if (dragLongPressTimer) clearTimeout(dragLongPressTimer);
  if (isDragging && dragBody) {
    Body.setStatic(dragBody, false);
    dragBody = null;
    isDragging = false;
    dragTouchId = null;
  } else {
    const now = Date.now();
    if (now - lastTouchTime < 350) return;
    lastTouchTime = now;
    const {x, y} = getCanvasPos(e);
    if (currentShape === 'custompoly') return;
    if (Composite.allBodies(world).length > maxBodies+8) return;
    if (getBodyAt(x, y)) return;
    const body = createBody(currentShape, x, y);
    if (body) Composite.add(world, body);
  }
  dragStart = null;
});

const mouse = Mouse.create(canvas);
const mouseConstraint = MouseConstraint.create(engine, {
  mouse: mouse,
  constraint: { stiffness: 0.2, render: {visible: false} }
});
Composite.add(world, mouseConstraint);
render.mouse = mouse;

Events.on(render, 'afterRender', function() {
  const mousePos = mouse.position;
  const found = Query.point(Composite.allBodies(world), mousePos)
    .find(b => b.label !== "wall" && b.label !== "Mouse Constraint");
  if (found) {
    const ctx = canvas.getContext('2d');
    ctx.save();
    ctx.strokeStyle = "#3b8eea";
    ctx.lineWidth = 2.1;
    if (found.circleRadius) {
      ctx.beginPath();
      ctx.arc(found.position.x, found.position.y, found.circleRadius+2, 0, 2*Math.PI);
      ctx.stroke();
    } else if (found.vertices) {
      ctx.beginPath();
      ctx.moveTo(found.vertices[0].x, found.vertices[0].y);
      for (let v of found.vertices) ctx.lineTo(v.x, v.y);
      ctx.closePath();
      ctx.stroke();
    }
    ctx.restore();
  }
});

let resizing = false, resizeStart = null, origRect = null;
function updateCanvasSize(newW, newH) {
  newW = Math.round(newW);
  newH = Math.round(newH);
  setCanvasSize(newW, newH);
  wrap.style.width = (newW+20)+'px';
  wrap.style.height = (newH+20)+'px';
  updateWalls();
}
function getTouch(e) {
  if (e.touches && e.touches.length) return e.touches[0];
  if (e.changedTouches && e.changedTouches.length) return e.changedTouches[0];
  return e;
}
function startResize(e) {
  resizing = true;
  let evt = getTouch(e);
  resizeStart = { x: evt.clientX, y: evt.clientY };
  origRect = { w: wrap.offsetWidth, h: wrap.offsetHeight };
  document.body.style.cursor = 'nwse-resize';
  e.preventDefault();
}
function moveResize(e) {
  if (!resizing) return;
  let evt = getTouch(e);
  const dx = evt.clientX - resizeStart.x;
  const dy = evt.clientY - resizeStart.y;
  let newW = origRect.w + dx;
  let newH = origRect.h + dy;
  updateCanvasSize(newW-20, newH-20);
}
function endResize() {
  if (resizing) {
    resizing = false;
    document.body.style.cursor = '';
  }
}
resizeHandle.addEventListener('mousedown', startResize, {passive:false});
document.addEventListener('mousemove', moveResize, {passive:false});
document.addEventListener('mouseup', endResize, {passive:false});
resizeHandle.addEventListener('touchstart', startResize, {passive:false});
document.addEventListener('touchmove', moveResize, {passive:false});
document.addEventListener('touchend', endResize, {passive:false});

// --------------------- 自定义多边形弹窗 ------------------
const polyModalBg = document.getElementById('poly-modal-bg');
const polyCanvas = document.getElementById('poly-canvas');
const polyCtx = polyCanvas.getContext('2d');
let polyPoints = [];
let polyFinished = false;
let polyLongPressTimer = null;
function showPolyModal() {
  polyPoints = [];
  polyFinished = false;
  polyModalBg.style.display = 'flex';
  drawPolyCanvas();
}
function closePolyModal() {
  polyModalBg.style.display = 'none';
  resetToolbarBtn();
  currentShape = 'rectangle';
}
function drawPolyCanvas() {
  polyCtx.clearRect(0, 0, polyCanvas.width, polyCanvas.height);
  polyCtx.save();
  polyCtx.strokeStyle = '#eef';
  polyCtx.lineWidth = 1.3;
  for(let i=1;i<polyCanvas.width;i+=32){
    polyCtx.beginPath();
    polyCtx.moveTo(i,0); polyCtx.lineTo(i,polyCanvas.height); polyCtx.stroke();
    polyCtx.beginPath();
    polyCtx.moveTo(0,i); polyCtx.lineTo(polyCanvas.width,i); polyCtx.stroke();
  }
  polyCtx.restore();
  if (polyPoints.length) {
    polyCtx.save();
    polyCtx.beginPath();
    polyCtx.moveTo(polyPoints[0].x, polyPoints[0].y);
    for(let i=1;i<polyPoints.length;i++)
      polyCtx.lineTo(polyPoints[i].x, polyPoints[i].y);
    if (polyFinished && polyPoints.length>2) polyCtx.closePath();
    polyCtx.strokeStyle = '#3b8eea';
    polyCtx.lineWidth = 2.1;
    polyCtx.stroke();
    polyCtx.restore();
    polyCtx.save();
    polyPoints.forEach((p,i) => {
      polyCtx.beginPath();
      polyCtx.arc(p.x, p.y, 5, 0, 2*Math.PI);
      polyCtx.fillStyle = i==0 ? '#e63' : '#2d7';
      polyCtx.fill();
      polyCtx.strokeStyle = '#fff';
      polyCtx.lineWidth = 1.2;
      polyCtx.stroke();
    });
    polyCtx.restore();
  }
}
polyCanvas.addEventListener('mousedown', function(e) {
  const {x, y} = getCanvasPos(e, polyCanvas);
  if (polyFinished) return;
  if (e.button === 0) {
    polyPoints.push({x,y});
    drawPolyCanvas();
  }
  else if (e.button === 2) {
    polyPoints.pop();
    drawPolyCanvas();
    e.preventDefault();
  }
});
polyCanvas.addEventListener('dblclick', function(e) {
  if (polyPoints.length<3) return;
  polyFinished = true;
  drawPolyCanvas();
});
polyCanvas.addEventListener('touchstart', function(e) {
  if (polyFinished) return;
  const {x, y} = getCanvasPos(e, polyCanvas);
  polyLongPressTimer = setTimeout(()=>{
    polyPoints.pop();
    drawPolyCanvas();
  }, 400);
  polyCanvas._touch = {x, y};
  e.preventDefault();
});
polyCanvas.addEventListener('touchend', function(e) {
  if (polyLongPressTimer) clearTimeout(polyLongPressTimer);
  if (e.touches.length === 0 && polyCanvas._touch) {
    polyPoints.push(polyCanvas._touch);
    drawPolyCanvas();
    polyCanvas._touch = null;
  }
});
polyCanvas.addEventListener('contextmenu', e => e.preventDefault());
polyCanvas.addEventListener('dblclick', function(e) {
  if (polyPoints.length<3) return;
  polyFinished = true;
  drawPolyCanvas();
});
document.getElementById('poly-finish').onclick = function(){
  if (polyPoints.length<3) {
    alert('需要至少3个点才能生成多边形');
    return;
  }
  const cx = polyPoints.reduce((a,b)=>a+b.x,0)/polyPoints.length;
  const cy = polyPoints.reduce((a,b)=>a+b.y,0)/polyPoints.length;
  const x = canvas.width/2;
  const y = canvas.height/2;
  const mapped = polyPoints.map(p => ({x:p.x-cx,y:p.y-cy}));
  const body = createBody('custompoly', x, y, mapped.map(p=>({x:p.x,y:p.y})));
  if (body) Composite.add(world, body);
  closePolyModal();
};
document.getElementById('poly-cancel').onclick = closePolyModal;
document.getElementById('poly-reset').onclick = function(){
  polyPoints = [];
  polyFinished = false;
  drawPolyCanvas();
};
document.addEventListener('keydown', function(e){
  if (polyModalBg.style.display === 'flex' && e.key === "Escape") {
    closePolyModal();
  }
});
</script>
</body>
</html>
